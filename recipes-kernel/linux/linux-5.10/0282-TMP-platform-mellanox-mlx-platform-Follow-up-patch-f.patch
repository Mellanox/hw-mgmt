From 8c7551a56fa7eab1fa8fb9cb8a63b228c95278a2 Mon Sep 17 00:00:00 2001
From: Vadim Pasternak <vadimp@nvidia.com>
Date: Mon, 1 May 2023 09:17:53 +0000
Subject: [PATCH platform-next 1/1] TMP: platform: mellanox: mlx-platform:
 Follow-up patch for COME BF3 support

Extend BF3 COME support after debug.
To be merged to previous patches.

Signed-off-by: Vadim Pasternak <vadimp@nvidia.com>
---
 drivers/platform/mellanox/mlx-platform.c | 144 +++++++++++++++--------
 1 file changed, 96 insertions(+), 48 deletions(-)

diff --git a/drivers/platform/mellanox/mlx-platform.c b/drivers/platform/mellanox/mlx-platform.c
index 605d57e95..d86168685 100644
--- a/drivers/platform/mellanox/mlx-platform.c
+++ b/drivers/platform/mellanox/mlx-platform.c
@@ -333,15 +333,17 @@
 #define MLXPLAT_I2C_MAIN_BUS_HANDLE_CREATED	0x02
 
 /* Lattice FPGA PCI configuration */
-#define PCI_VENDOR_ID_LATTICE		0x1204
-#define PCI_DEVICE_ID_LATTICE_LFD2NX40	0x9c1d
-#define MLXPLAT_FPGA_PCI_BAR0_SIZE	0x4000
-#define MLXPLAT_FPGA_PCI_BASE_OFFSET	0x00000000
-#define MLXPLAT_FPGA_PCI_ADDR_OFFSET	MLXPLAT_FPGA_PCI_BASE_OFFSET
-#define MLXPLAT_FPGA_PCI_DATA_OFFSET	(MLXPLAT_FPGA_PCI_BASE_OFFSET + 0x02)
-#define MLXPLAT_FPGA_PCI_CTRL_OFFSET	(MLXPLAT_FPGA_PCI_BASE_OFFSET + 0x04)
-#define MLXPLAT_FPGA_PCI_STAT_OFFSET	(MLXPLAT_FPGA_PCI_BASE_OFFSET + 0x06)
-#define MLXPLAT_FPGA_PCI_I2C_LPC_OFFSET	(MLXPLAT_FPGA_PCI_BASE_OFFSET + 0x400)
+#define PCI_VENDOR_ID_LATTICE			0x1204
+#define PCI_DEVICE_ID_LATTICE_LFD2NX40		0x9c1d
+#define MLXPLAT_FPGA_PCI_BAR0_SIZE		0x4000
+#define MLXPLAT_FPGA_PCI_BASE_OFFSET		0x00000000
+#define MLXPLAT_FPGA_PCI_MSB_ADDR		0x25
+#define MLXPLAT_FPGA_PCI_LSB_ADDR_OFFSET	MLXPLAT_FPGA_PCI_BASE_OFFSET
+#define MLXPLAT_FPGA_PCI_MSB_ADDR_OFFSET	(MLXPLAT_FPGA_PCI_BASE_OFFSET + 0x01)
+#define MLXPLAT_FPGA_PCI_DATA_IN_OFFSET		(MLXPLAT_FPGA_PCI_BASE_OFFSET + 0x02)
+#define MLXPLAT_FPGA_PCI_DATA_OUT_OFFSET	(MLXPLAT_FPGA_PCI_BASE_OFFSET + 0x03)
+#define MLXPLAT_FPGA_PCI_CTRL_OFFSET		(MLXPLAT_FPGA_PCI_BASE_OFFSET + 0x04)
+#define MLXPLAT_FPGA_PCI_STAT_OFFSET		(MLXPLAT_FPGA_PCI_BASE_OFFSET + 0x05)
 
 #define MLXPLAT_FPGA_PCI_CTRL_READ	BIT(0)
 #define MLXPLAT_FPGA_PCI_CTRL_WRITE	BIT(1)
@@ -361,6 +363,7 @@
  * @hotplug_resources_size: size of system hotplug resources
  * @hi2c_main_init_status: init status of I2C main bus
  * @mux_added: number of added mux segments
+ * @irq_fpga: FPGA IRQ number
  */
 struct mlxplat_priv {
 	struct platform_device *pdev_i2c;
@@ -375,6 +378,7 @@ struct mlxplat_priv {
 	unsigned int hotplug_resources_size;
 	u8 i2c_main_init_status;
 	int mux_added;
+	int irq_fpga;
 };
 
 static struct platform_device *mlxplat_dev;
@@ -5868,12 +5872,12 @@ static const struct regmap_config mlxplat_mlxcpld_regmap_config_eth_modular = {
 static int mlxplat_fpga_completion_wait(struct mlxplat_mlxcpld_regmap_context *ctx)
 {
 	unsigned long end;
-	u16 status;
+	u8 status;
 
 	end = jiffies + msecs_to_jiffies(MLXPLAT_FPGA_PCI_TO);
 	do {
-		status = ioread16(ctx->base + MLXPLAT_FPGA_PCI_STAT_OFFSET);
-		if (status & MLXPLAT_FPGA_PCI_COMPLETED)
+		status = ioread8(ctx->base + MLXPLAT_FPGA_PCI_STAT_OFFSET);
+		if (!(status & MLXPLAT_FPGA_PCI_COMPLETED))
 			return 0;
 		cond_resched();
 	} while (time_before(jiffies, end));
@@ -5893,16 +5897,17 @@ static int mlxplat_fpga_reg_read(void *context, unsigned int reg, unsigned int *
 		return err;
 
 	/* Set address in register space */
-	iowrite16(reg, ctx->base + MLXPLAT_FPGA_PCI_ADDR_OFFSET);
+	iowrite8(MLXPLAT_FPGA_PCI_MSB_ADDR, ctx->base + MLXPLAT_FPGA_PCI_MSB_ADDR_OFFSET);
+	iowrite8(reg, ctx->base + MLXPLAT_FPGA_PCI_LSB_ADDR_OFFSET);
 	/* Activate read operation */
-	iowrite16(MLXPLAT_FPGA_PCI_CTRL_READ, ctx->base + MLXPLAT_FPGA_PCI_CTRL_OFFSET);
+	iowrite8(MLXPLAT_FPGA_PCI_CTRL_READ, ctx->base + MLXPLAT_FPGA_PCI_CTRL_OFFSET);
 	/* Verify transaction completion */
 	err = mlxplat_fpga_completion_wait(ctx);
 	if (err)
 		return err;
 
 	/* Read data */
-	*val = ioread16(ctx->base + MLXPLAT_FPGA_PCI_DATA_OFFSET);
+	*val = ioread8(ctx->base + MLXPLAT_FPGA_PCI_DATA_IN_OFFSET);
 
 	return 0;
 }
@@ -5919,11 +5924,12 @@ static int mlxplat_fpga_reg_write(void *context, unsigned int reg, unsigned int
 		return err;
 
 	/* Set address in register space */
-	iowrite16(reg, ctx->base + MLXPLAT_FPGA_PCI_ADDR_OFFSET);
+	iowrite8(MLXPLAT_FPGA_PCI_MSB_ADDR, ctx->base + MLXPLAT_FPGA_PCI_MSB_ADDR_OFFSET);
+	iowrite8(reg, ctx->base + MLXPLAT_FPGA_PCI_LSB_ADDR_OFFSET);
 	/* Set data to be written */
-	iowrite16(val, ctx->base + MLXPLAT_FPGA_PCI_DATA_OFFSET);
+	iowrite8(val, ctx->base + MLXPLAT_FPGA_PCI_DATA_OUT_OFFSET);
 	/* Activate write operation */
-	iowrite16(MLXPLAT_FPGA_PCI_CTRL_WRITE, ctx->base + MLXPLAT_FPGA_PCI_CTRL_OFFSET);
+	iowrite8(MLXPLAT_FPGA_PCI_CTRL_WRITE, ctx->base + MLXPLAT_FPGA_PCI_CTRL_OFFSET);
 
 	return 0;
 }
@@ -6465,6 +6471,12 @@ static const struct dmi_system_id mlxplat_dmi_table[] __initconst = {
 			DMI_MATCH(DMI_BOARD_NAME, "VMOD0016"),
 		},
 	},
+	{
+		.callback = mlxplat_dmi_bf3_comex_default_matched,
+		.matches = {
+			DMI_EXACT_MATCH(DMI_PRODUCT_SKU, "HI151"),
+		},
+	},
 	{
 		.callback = mlxplat_dmi_l1_switch_matched,
 		.matches = {
@@ -6664,21 +6676,21 @@ mlxplat_pci_fpga_device_init(struct resource **hotplug_resources,
 
 	err = pci_enable_device(pci_dev);
 	if (err) {
-		dev_err(&mlxplat_dev->dev, "pci_enable_device failed\n");
+		dev_err(&pci_dev->dev, "pci_enable_device failed with error %d\n", err);
 		goto fail_pci_enable_device;
 	}
 
-	err = pci_request_regions(pci_dev, "mlx-patform");
+	err = pci_request_region(pci_dev, 0, "mlxplat_fpga");
 	if (err) {
-		dev_err(&mlxplat_dev->dev, "pci_request_regions failed\n");
+		dev_err(&pci_dev->dev, "pci_request_regions failed with error %d\n", err);
 		goto fail_pci_request_regions;
 	}
 
-	err = dma_set_mask_and_coherent(&mlxplat_dev->dev, DMA_BIT_MASK(64));
+	err = dma_set_mask_and_coherent(&pci_dev->dev, DMA_BIT_MASK(64));
 	if (err) {
-		err = dma_set_mask(&mlxplat_dev->dev, DMA_BIT_MASK(32));
+		err = dma_set_mask(&pci_dev->dev, DMA_BIT_MASK(32));
 		if (err) {
-			dev_err(&mlxplat_dev->dev, "dma_set_mask failed\n");
+			dev_err(&pci_dev->dev, "dma_set_mask failed with error %d\n", err);
 			goto fail_pci_set_dma_mask;
 		}
 	}
@@ -6689,7 +6701,7 @@ mlxplat_pci_fpga_device_init(struct resource **hotplug_resources,
 		goto fail_pci_resource_len_check;
 	}
 
-	mlxplat_mlxcpld_regmap_ctx.base = devm_ioremap(&mlxplat_dev->dev,
+	mlxplat_mlxcpld_regmap_ctx.base = devm_ioremap(&pci_dev->dev,
 						       pci_resource_start(pci_dev, 0),
 						       pci_resource_len(pci_dev, 0));
 	if (!mlxplat_mlxcpld_regmap_ctx.base) {
@@ -6698,26 +6710,14 @@ mlxplat_pci_fpga_device_init(struct resource **hotplug_resources,
 		goto fail_ioremap;
 	}
 
-	/* Set mapped base address of I2C-LPC bridge over PCIe */
-	mlxplat_i2c->addr = mlxplat_mlxcpld_regmap_ctx.base +
-			    MLXPLAT_FPGA_PCI_I2C_LPC_OFFSET;
-
 	pci_set_master(pci_dev);
 
-	mlxplat_dev = platform_device_register_simple(MLX_PLAT_DEVICE_NAME, PLATFORM_DEVID_NONE,
-						      NULL, 0);
-	if (IS_ERR(mlxplat_dev)) {
-		err = PTR_ERR(mlxplat_dev);
-		goto fail_platform_device_register_simple;
-	}
-
 	*hotplug_resources = mlxplat_mlxfpga_resources;
 	*hotplug_resources_size = ARRAY_SIZE(mlxplat_mlxfpga_resources);
 	*fpga_dev = pci_dev;
 
 	return 0;
 
-fail_platform_device_register_simple:
 fail_ioremap:
 fail_pci_resource_len_check:
 fail_pci_set_dma_mask:
@@ -6742,12 +6742,10 @@ mlxplat_pre_init(struct resource **hotplug_resources, unsigned int *hotplug_reso
 	int err;
 
 	err = mlxplat_pci_fpga_device_init(hotplug_resources, hotplug_resources_size, &fpga_dev);
-	if (!err)
-		return 0;
-	else if (err != -ENODEV)
-		return err;
+	if (err == -ENODEV)
+		return mlxplat_lpc_cpld_device_init(hotplug_resources, hotplug_resources_size);
 
-	return mlxplat_lpc_cpld_device_init(hotplug_resources, hotplug_resources_size);
+	return err;
 }
 
 static void mlxplat_post_exit(void)
@@ -6765,6 +6763,7 @@ static int mlxplat_post_init(struct mlxplat_priv *priv)
 	/* Add hotplug driver */
 	if (mlxplat_hotplug) {
 		mlxplat_hotplug->regmap = priv->regmap;
+		mlxplat_hotplug->irq = priv->irq_fpga;
 		priv->pdev_hotplug =
 		platform_device_register_resndata(&mlxplat_dev->dev,
 						  "mlxreg-hotplug", PLATFORM_DEVID_NONE,
@@ -6981,6 +6980,10 @@ static int mlxplat_i2c_main_init(struct mlxplat_priv *priv)
 	nr = (nr == mlxplat_max_adap_num) ? -1 : nr;
 	mlxplat_i2c->regmap = priv->regmap;
 	mlxplat_i2c->handle = priv;
+
+	/* Set mapped base address of I2C-LPC bridge over PCIe */
+	if (fpga_dev)
+		mlxplat_i2c->addr = mlxplat_mlxcpld_regmap_ctx.base;
 	priv->pdev_i2c = platform_device_register_resndata(&mlxplat_dev->dev, "i2c_mlxcpld",
 							   nr, priv->hotplug_resources,
 							   priv->hotplug_resources_size,
@@ -7011,20 +7014,26 @@ static void mlxplat_i2c_main_exit(struct mlxplat_priv *priv)
 		platform_device_unregister(priv->pdev_i2c);
 }
 
-static int __init mlxplat_init(void)
+static int mlxplat_probe(struct platform_device *pdev)
 {
 	unsigned int hotplug_resources_size;
 	struct resource *hotplug_resources;
+	struct acpi_device *acpi_dev;
 	struct mlxplat_priv *priv;
-	int i, err;
+	int irq_fpga = 0, i, err;
 
-	if (!dmi_check_system(mlxplat_dmi_table))
-		return -ENODEV;
+	acpi_dev = ACPI_COMPANION(&pdev->dev);
+	if (acpi_dev) {
+		irq_fpga = acpi_dev_gpio_irq_get(acpi_dev, 0);
+		if (irq_fpga < 0)
+			return -ENODEV;
+	}
 
 	err = mlxplat_pre_init(&hotplug_resources, &hotplug_resources_size);
 	if (err)
 		return err;
 
+	mlxplat_dev = pdev;
 	priv = devm_kzalloc(&mlxplat_dev->dev, sizeof(struct mlxplat_priv),
 			    GFP_KERNEL);
 	if (!priv) {
@@ -7034,6 +7043,7 @@ static int __init mlxplat_init(void)
 	platform_set_drvdata(mlxplat_dev, priv);
 	priv->hotplug_resources = hotplug_resources;
 	priv->hotplug_resources_size = hotplug_resources_size;
+	priv->irq_fpga = irq_fpga;
 
 	if (!mlxplat_regmap_config)
 		mlxplat_regmap_config = &mlxplat_mlxcpld_regmap_config;
@@ -7083,9 +7093,8 @@ static int __init mlxplat_init(void)
 
 	return err;
 }
-module_init(mlxplat_init);
 
-static void __exit mlxplat_exit(void)
+static int mlxplat_remove(struct platform_device *pdev)
 {
 	struct mlxplat_priv *priv = platform_get_drvdata(mlxplat_dev);
 
@@ -7096,6 +7105,45 @@ static void __exit mlxplat_exit(void)
 	mlxplat_pre_exit(priv);
 	mlxplat_i2c_main_exit(priv);
 	mlxplat_post_exit();
+	return 0;
+}
+
+static const struct acpi_device_id mlxplat_acpi_table[] = {
+	{ "MLNXBF49", 0 },
+	{}
+};
+MODULE_DEVICE_TABLE(acpi, mlxplat_acpi_table);
+
+static struct platform_driver mlxplat_driver = {
+	.driver		= {
+		.name	= "mlxplat",
+		.acpi_match_table = ACPI_PTR(mlxplat_acpi_table),
+		.probe_type = PROBE_FORCE_SYNCHRONOUS,
+	},
+	.probe		= mlxplat_probe,
+	.remove		= mlxplat_remove,
+};
+
+static int __init mlxplat_init(void)
+{
+	int err;
+
+	if (!dmi_check_system(mlxplat_dmi_table))
+		return -ENODEV;
+
+	err = platform_driver_register(&mlxplat_driver);
+	if (err)
+		return err;
+	return 0;
+}
+module_init(mlxplat_init);
+
+static void __exit mlxplat_exit(void)
+{
+	if (mlxplat_dev)
+		platform_device_unregister(mlxplat_dev);
+
+	platform_driver_unregister(&mlxplat_driver);
 }
 module_exit(mlxplat_exit);
 
-- 
2.20.1

