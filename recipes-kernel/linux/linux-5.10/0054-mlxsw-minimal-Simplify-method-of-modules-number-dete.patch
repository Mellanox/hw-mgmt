From 675042fec21be3fbd12388b239676608759f0497 Mon Sep 17 00:00:00 2001
From: Vadim Pasternak <vadimp@nvidia.com>
Date: Mon, 19 Jul 2021 17:07:02 +0000
Subject: [PATCH backport 5.10 054/182] mlxsw: minimal: Simplify method of
 modules number detection

Remove unnecessary access to PMLP register, used to find the number of
module supported by the system. Obtain this information through MGPIR
register instead. The motivation is reduce access to the ASIC. Getting
the number of modules though MGPIR required only single transaction,
while getting this info through PMLP required to run the number of
transaction up to the local ports maximum.

Signed-off-by: Vadim Pasternak <vadimp@nvidia.com>
---
 drivers/net/ethernet/mellanox/mlxsw/minimal.c | 107 ++++--------------
 1 file changed, 20 insertions(+), 87 deletions(-)

diff --git a/drivers/net/ethernet/mellanox/mlxsw/minimal.c b/drivers/net/ethernet/mellanox/mlxsw/minimal.c
index af4c9b44d9cf..a8c67b763c8b 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/minimal.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/minimal.c
@@ -131,23 +131,6 @@ static const struct ethtool_ops mlxsw_m_port_ethtool_ops = {
 	.get_module_eeprom_by_page = mlxsw_m_get_module_eeprom_by_page,
 };
 
-static int
-mlxsw_m_port_module_info_get(struct mlxsw_m *mlxsw_m, u8 local_port,
-			     u8 *p_module, u8 *p_width)
-{
-	char pmlp_pl[MLXSW_REG_PMLP_LEN];
-	int err;
-
-	mlxsw_reg_pmlp_pack(pmlp_pl, local_port);
-	err = mlxsw_reg_query(mlxsw_m->core, MLXSW_REG(pmlp), pmlp_pl);
-	if (err)
-		return err;
-	*p_module = mlxsw_reg_pmlp_module_get(pmlp_pl, 0);
-	*p_width = mlxsw_reg_pmlp_width_get(pmlp_pl);
-
-	return 0;
-}
-
 static int
 mlxsw_m_port_dev_addr_get(struct mlxsw_m_port *mlxsw_m_port)
 {
@@ -165,7 +148,7 @@ mlxsw_m_port_dev_addr_get(struct mlxsw_m_port *mlxsw_m_port)
 	 * to be such it does not overflow when adding local_port
 	 * value.
 	 */
-	dev->dev_addr[ETH_ALEN - 1] += mlxsw_m_port->module + 1;
+	dev->dev_addr[ETH_ALEN - 1] = mlxsw_m_port->module + 1;
 	return 0;
 }
 
@@ -244,91 +227,46 @@ static void mlxsw_m_port_remove(struct mlxsw_m *mlxsw_m, u8 local_port)
 	mlxsw_core_port_fini(mlxsw_m->core, local_port);
 }
 
-static int mlxsw_m_port_module_map(struct mlxsw_m *mlxsw_m, u8 local_port,
-				   u8 *last_module)
+static int mlxsw_m_ports_create(struct mlxsw_m *mlxsw_m)
 {
-	unsigned int max_ports = mlxsw_core_max_ports(mlxsw_m->core);
-	u8 module, width;
-	int err;
+	char mgpir_pl[MLXSW_REG_MGPIR_LEN];
+	int i, err;
 
-	/* Fill out to local port mapping array */
-	err = mlxsw_m_port_module_info_get(mlxsw_m, local_port, &module,
-					   &width);
+	mlxsw_reg_mgpir_pack(mgpir_pl);
+	err = mlxsw_reg_query(mlxsw_m->core, MLXSW_REG(mgpir), mgpir_pl);
 	if (err)
 		return err;
 
-	if (!width)
-		return 0;
-	/* Skip, if port belongs to the cluster */
-	if (module == *last_module)
+	mlxsw_reg_mgpir_unpack(mgpir_pl, NULL, NULL, NULL,
+			       &mlxsw_m->max_ports);
+	if (!mlxsw_m->max_ports)
 		return 0;
-	*last_module = module;
-
-	if (WARN_ON_ONCE(module >= max_ports))
-		return -EINVAL;
-	mlxsw_m->module_to_port[module] = ++mlxsw_m->max_ports;
-
-	return 0;
-}
 
-static void mlxsw_m_port_module_unmap(struct mlxsw_m *mlxsw_m, u8 module)
-{
-	mlxsw_m->module_to_port[module] = -1;
-}
-
-static int mlxsw_m_ports_create(struct mlxsw_m *mlxsw_m)
-{
-	unsigned int max_ports = mlxsw_core_max_ports(mlxsw_m->core);
-	u8 last_module = max_ports;
-	int i;
-	int err;
-
-	mlxsw_m->ports = kcalloc(max_ports, sizeof(*mlxsw_m->ports),
+	mlxsw_m->ports = kcalloc(mlxsw_m->max_ports, sizeof(*mlxsw_m->ports),
 				 GFP_KERNEL);
 	if (!mlxsw_m->ports)
 		return -ENOMEM;
 
-	mlxsw_m->module_to_port = kmalloc_array(max_ports, sizeof(int),
+	mlxsw_m->module_to_port = kmalloc_array(mlxsw_m->max_ports, sizeof(int),
 						GFP_KERNEL);
 	if (!mlxsw_m->module_to_port) {
 		err = -ENOMEM;
 		goto err_module_to_port_alloc;
 	}
 
-	/* Invalidate the entries of module to local port mapping array */
-	for (i = 0; i < max_ports; i++)
-		mlxsw_m->module_to_port[i] = -1;
-
-	/* Fill out module to local port mapping array */
-	for (i = 1; i < max_ports; i++) {
-		err = mlxsw_m_port_module_map(mlxsw_m, i, &last_module);
-		if (err)
-			goto err_module_to_port_map;
-	}
-
-	/* Create port objects for each valid entry */
+	/* Create port objects for each entry. */
 	for (i = 0; i < mlxsw_m->max_ports; i++) {
-		if (mlxsw_m->module_to_port[i] > 0) {
-			err = mlxsw_m_port_create(mlxsw_m,
-						  mlxsw_m->module_to_port[i],
-						  i);
-			if (err)
-				goto err_module_to_port_create;
-		}
+		mlxsw_m->module_to_port[i] = i;
+		err = mlxsw_m_port_create(mlxsw_m, mlxsw_m->module_to_port[i], i);
+		if (err)
+			goto err_module_to_port_create;
 	}
 
 	return 0;
 
 err_module_to_port_create:
-	for (i--; i >= 0; i--) {
-		if (mlxsw_m->module_to_port[i] > 0)
-			mlxsw_m_port_remove(mlxsw_m,
-					    mlxsw_m->module_to_port[i]);
-	}
-	i = max_ports;
-err_module_to_port_map:
-	for (i--; i > 0; i--)
-		mlxsw_m_port_module_unmap(mlxsw_m, i);
+	for (i--; i >= 0; i--)
+		mlxsw_m_port_remove(mlxsw_m, mlxsw_m->module_to_port[i]);
 	kfree(mlxsw_m->module_to_port);
 err_module_to_port_alloc:
 	kfree(mlxsw_m->ports);
@@ -339,13 +277,8 @@ static void mlxsw_m_ports_remove(struct mlxsw_m *mlxsw_m)
 {
 	int i;
 
-	for (i = 0; i < mlxsw_m->max_ports; i++) {
-		if (mlxsw_m->module_to_port[i] > 0) {
-			mlxsw_m_port_remove(mlxsw_m,
-					    mlxsw_m->module_to_port[i]);
-			mlxsw_m_port_module_unmap(mlxsw_m, i);
-		}
-	}
+	for (i = 0; i < mlxsw_m->max_ports; i++)
+		mlxsw_m_port_remove(mlxsw_m, mlxsw_m->module_to_port[i]);
 
 	kfree(mlxsw_m->module_to_port);
 	kfree(mlxsw_m->ports);
-- 
2.20.1

