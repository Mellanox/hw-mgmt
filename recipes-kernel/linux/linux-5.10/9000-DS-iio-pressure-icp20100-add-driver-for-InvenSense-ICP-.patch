From b928a9e8c41aceedd46a4052afcf325475c1acd0 Mon Sep 17 00:00:00 2001
From: Michael Shych <michaelsh@nvidia.com>
Date: Thu, 8 Sep 2022 13:26:04 +0300
Subject: [PATCH 1/1] iio: pressure: icp20100: add driver for InvenSense
 ICP-201xx

InvenSense ICP-201xx sensors are a family of barometric pressure
and temperature sensor.
This is a version of still not upstreamed kernel driver provided by TDK.

Signed-off-by: Michael Shych <michaelsh@nvidia.com>
---
 drivers/iio/pressure/Kconfig         |  15 +
 drivers/iio/pressure/Makefile        |   2 +
 drivers/iio/pressure/icp201xx.c      | 733 +++++++++++++++++++++++++++++++++++
 drivers/iio/pressure/icp201xx.h      | 128 ++++++
 drivers/iio/pressure/icp201xx_core.c | 551 ++++++++++++++++++++++++++
 drivers/iio/pressure/icp201xx_core.h | 506 ++++++++++++++++++++++++
 drivers/iio/pressure/icp201xx_i2c.c  | 158 ++++++++
 drivers/iio/pressure/icp201xx_i2c.h  |  64 +++
 8 files changed, 2157 insertions(+)
 create mode 100755 drivers/iio/pressure/icp201xx.c
 create mode 100755 drivers/iio/pressure/icp201xx.h
 create mode 100755 drivers/iio/pressure/icp201xx_core.c
 create mode 100755 drivers/iio/pressure/icp201xx_core.h
 create mode 100755 drivers/iio/pressure/icp201xx_i2c.c
 create mode 100755 drivers/iio/pressure/icp201xx_i2c.h

diff --git a/drivers/iio/pressure/Kconfig b/drivers/iio/pressure/Kconfig
index fc0d3cfca..9c2b56f6f 100644
--- a/drivers/iio/pressure/Kconfig
+++ b/drivers/iio/pressure/Kconfig
@@ -111,6 +111,21 @@ config ICP10100
 	  To compile this driver as a module, choose M here: the module
 	  will be called icp10100.
 
+config ICP201XX
+        tristate "InvenSense ICP-201xx pressure and temperature sensor"
+        depends on (I2C || SPI_MASTER)
+        select IIO_BUFFER
+        select IIO_TRIGGERED_BUFFER
+        select CRC32
+	select ICP201XX_I2C
+        help
+	  Say yes here to build support for the Invensense ICP201XX
+
+config ICP201XX_I2C
+	tristate
+	depends on ICP201XX
+	depends on I2C
+
 config MPL115
 	tristate
 
diff --git a/drivers/iio/pressure/Makefile b/drivers/iio/pressure/Makefile
index 083ae87ff..7c4c9df30 100644
--- a/drivers/iio/pressure/Makefile
+++ b/drivers/iio/pressure/Makefile
@@ -15,6 +15,8 @@ obj-$(CONFIG_IIO_CROS_EC_BARO) += cros_ec_baro.o
 obj-$(CONFIG_HID_SENSOR_PRESS)   += hid-sensor-press.o
 obj-$(CONFIG_HP03) += hp03.o
 obj-$(CONFIG_ICP10100) += icp10100.o
+obj-$(CONFIG_ICP201XX) += icp201xx.o icp201xx_core.o
+obj-$(CONFIG_ICP201XX_I2C) += icp201xx_i2c.o
 obj-$(CONFIG_MPL115) += mpl115.o
 obj-$(CONFIG_MPL115_I2C) += mpl115_i2c.o
 obj-$(CONFIG_MPL115_SPI) += mpl115_spi.o
diff --git a/drivers/iio/pressure/icp201xx.c b/drivers/iio/pressure/icp201xx.c
new file mode 100755
index 000000000..b8fecff82
--- /dev/null
+++ b/drivers/iio/pressure/icp201xx.c
@@ -0,0 +1,733 @@
+/*
+ * Copyright (C) 2017-2020 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/pm.h>
+#include <linux/crc8.h>
+#include <linux/atomic.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/hrtimer.h>
+#include <linux/ktime.h>
+#ifdef CONFIG_RTC_INTF_ALARM
+#include <linux/android_alarm.h>
+#endif
+#include <linux/irqreturn.h>
+#include <linux/math64.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/trigger.h>
+#include <linux/iio/trigger_consumer.h>
+#include <linux/iio/triggered_buffer.h>
+#include <linux/iio/sysfs.h>
+#include <linux/version.h>
+
+#include "icp201xx.h"
+#include "icp201xx_core.h"
+#include "icp201xx_i2c.h"
+
+#define ICP201XX_VERSION "0.0.2_test1"
+
+enum icp201xx_attributes {
+        ICP201XX_ATTR_SAMP_AVAIL_FREQ,
+        ICP201XX_ATTR_MODE,
+        ICP201XX_ATTR_CALIBDATA,
+};
+
+enum icp201xx_channel {
+        ICP201XX_CHANNEL_PRESSURE,
+        ICP201XX_CHANNEL_TEMPERATURE,
+        ICP201XX_CHANNEL_TIMESTAMP,
+};
+
+static const unsigned icp201xx_min_freq = 1;
+static const unsigned icp201xx_max_freq[] = {
+        [ICP201XX_MODE_0] = 25,
+        [ICP201XX_MODE_1] = 120,
+        [ICP201XX_MODE_2] = 40,
+        [ICP201XX_MODE_3] = 2,
+        [ICP201XX_MODE_4] = 40,
+};
+
+
+static const char *icp201xx_mode_strings[] = {
+        [ICP201XX_MODE_0] = "0",
+        [ICP201XX_MODE_1] = "1",
+        [ICP201XX_MODE_2] = "2",
+        [ICP201XX_MODE_3] = "3",
+        [ICP201XX_MODE_4] = "4",
+};
+
+
+#ifdef CONFIG_RTC_INTF_ALARM
+static inline u64 icp201xx_get_time(void)
+{
+	ktime_t ts;
+
+	/* Workaround for some platform on which monotonic clock and
+	 * Android SystemClock has a gap.
+	 * Use ktime_to_timespec(alarm_get_elapsed_realtime()) instead of
+	 * get_monotonic_boottime() for these platform
+	 */
+	ts = ktime_to_timespec(alarm_get_elapsed_realtime());
+
+	return timespec_to_ns(ts);
+}
+#else
+static inline u64 icp201xx_get_time(void)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 19, 0)
+	/* kernel ~4.18 */
+	struct timespec ts;
+	get_monotonic_boottime(&ts);
+
+	return timespec_to_ns(&ts);
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(5, 3, 0)
+	/* kernel 4.19~5.2 */
+	return ktime_get_boot_ns();
+#else
+	/* kernel 5.3~ */
+	return ktime_get_boottime_ns();
+#endif
+}
+#endif
+
+#define ICP201XX_CRC8_POLYNOMIAL		0x31
+
+DECLARE_CRC8_TABLE(icp201xx_crc8_table);
+
+#define ICP201XX_INIT_TO    100
+
+static int icp201xx_init_chip(struct icp201xx_state *st)
+{
+	int ret, to=ICP201XX_INIT_TO;
+	u8 buf;
+
+	do {
+		ret = icp201xx_reg_write(st, 0xEE, 0xF0);
+		if (!ret)
+			break;
+
+		udelay(5);
+		to-=5;
+	} while(to);
+
+	if (!to)
+		return -ENXIO;
+
+	ret = icp201xx_reg_read(st, ICP201XX_REG_VERSION, &buf);
+	if (ret)
+		return ret;
+
+	pr_info("ICP201XX(version %s) VERSION : %X", ICP201XX_VERSION, buf);
+
+	if (buf == 0xB2) {
+		st->version = ICP201XX_VERSION_B;
+		return 0;
+	}
+	else if (buf == 0x00)
+		st->version = ICP201XX_VERSION_A;
+	else
+		return -EINVAL;
+
+	ret = icp201xx_reg_read(st, ICP201XX_REG_DEVICE_ID, &buf);
+	if (ret)
+		return ret;
+
+	pr_info("ICP201XX(version %s) DEVICE_ID : %X", ICP201XX_VERSION, buf);
+
+	ret = icp201xx_reg_read(st, ICP201XX_REG_OTP_STATUS2, &buf);
+	if (ret)
+		return ret;
+
+	if (buf == 0x01) {
+		pr_info("ICP201XX boot sequence was already done.");
+		return 0;
+	}
+
+	icp201xx_OTP_bootup_cfg(st);
+
+	return 0;
+}
+
+static int icp201xx_process_raw_data(struct icp201xx_state *st, uint8_t packet_cnt, uint8_t *data,int32_t * pressure, int32_t * temperature)
+{
+	uint8_t i, offset = 0;
+
+	for ( i = 0 ; i < packet_cnt ; i++ ) {
+		if ( st->fifo_readout_mode == ICP201XX_FIFO_READOUT_MODE_PRES_TEMP) {
+			pressure[i] = (int32_t)((( data[offset+2] & 0x0f) << 16) | (data[offset+1] << 8) | data[offset]) ;
+			offset += 3;
+			temperature[i] = (int32_t)(((data[offset+2] & 0x0f) << 16) | (data[offset+1] << 8) | data[offset]) ;
+			offset += 3;
+		} else if ( st->fifo_readout_mode == ICP201XX_FIFO_READOUT_MODE_TEMP_ONLY) {
+			temperature[i] = (int32_t)(((data[offset+2] & 0x0f) << 16) | (data[offset+1] << 8) | data[offset]) ;
+			offset += 3;
+		} else if( st->fifo_readout_mode == ICP201XX_FIFO_READOUT_MODE_TEMP_PRES) {
+			temperature[i] = (int32_t)(((data[offset+2] & 0x0f) << 16) | (data[offset+1] << 8) | data[offset]) ;
+			offset += 3;
+			pressure[i] = (int32_t)((( data[offset+2] & 0x0f) << 16) | (data[offset+1] << 8) | data[offset]) ;
+			offset += 3;
+		} else if( st->fifo_readout_mode == ICP201XX_FIFO_READOUT_MODE_PRES_ONLY) {
+			pressure[i] = (int32_t)((( data[offset+2] & 0x0f) << 16) | (data[offset+1] << 8) | data[offset]) ;
+			offset += 3;
+		}
+	}
+	return 0;
+}
+
+static void display_press_temp(uint8_t fifo_packets, int32_t *data_temp, int32_t *data_press)
+{
+	uint8_t i;
+	for ( i = 0 ; i < fifo_packets ; i++) {
+		if (data_press[i] & 0x080000 )
+			data_press[i] |= 0xFFF00000;
+
+		if (data_temp[i] & 0x080000 )
+			data_temp[i] |= 0xFFF00000;
+	}
+}
+
+static irqreturn_t icp201xx_read_measurement(int irq, void *p)
+{
+	struct iio_poll_func *pf = p;
+	struct iio_dev *indio_dev = pf->indio_dev;
+	struct icp201xx_state *st = iio_priv(indio_dev);
+
+	struct {
+		uint32_t pressure;
+		uint32_t temp;
+	} __packed data;
+	uint64_t ts;
+	uint8_t ts_buf[10] = {0,};
+
+	uint8_t fifo_cnt = 0;
+	uint8_t fifo_data[96] = {0,};
+	static int32_t data_temp[20], data_press[20];
+
+	int ret;
+
+	ts = icp201xx_get_time();
+	memcpy(ts_buf, &ts, 8);
+
+	icp201xx_get_fifo_count(st, &fifo_cnt);
+
+	if(fifo_cnt > 0) {
+		icp201xx_get_fifo_data(st, fifo_cnt, fifo_data);
+		icp201xx_process_raw_data(st, fifo_cnt > 1 ? 2 : fifo_cnt, fifo_data, data_press, data_temp);
+		display_press_temp(fifo_cnt, data_temp, data_press);
+		data.pressure = data_press[0];
+		data.temp = data_temp[0];
+	} else {
+		if (data_press[1] != 0)
+			data.pressure = data_press[1];
+		else
+			data.pressure = data_press[0];
+
+		if (data_temp[1] != 0)
+			data.temp = data_temp[1];
+		else
+			data.temp = data_temp[0];
+
+	}
+
+	icp201xx_read_dummy_data(st);
+
+	ret = iio_push_to_buffers(indio_dev, (uint8_t *)&data);
+	if (ret)
+		dev_err(&st->client->dev, "iio push error %d\n", ret);
+
+	ret = iio_push_to_buffers(indio_dev, ts_buf);
+	if (ret)
+		dev_err(&st->client->dev, "iio push error %d\n", ret);
+
+	iio_trigger_notify_done(indio_dev->trig);
+	return IRQ_HANDLED;
+}
+
+static enum hrtimer_restart icp201xx_timer_handler(struct hrtimer *timer)
+{
+	struct icp201xx_state *st = container_of(timer, struct icp201xx_state,
+						timer);
+	ktime_t period;
+	unsigned long flags;
+
+	spin_lock_irqsave(&st->period_lock, flags);
+	period = st->period;
+	spin_unlock_irqrestore(&st->period_lock, flags);
+	hrtimer_forward_now(timer, period);
+
+	iio_trigger_poll(st->trig);
+
+	return HRTIMER_RESTART;
+}
+
+static int icp201xx_trig_set_state(struct iio_trigger *trig, bool state)
+{
+	struct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);
+	struct icp201xx_state *st = iio_priv(indio_dev);
+	ktime_t period;
+	unsigned long flags;
+
+	if (state) {
+		inv_run_icp201xx_in_polling(st, atomic_read(&st->mode), st->frequency);
+		spin_lock_irqsave(&st->period_lock, flags);
+		period = st->period;
+		spin_unlock_irqrestore(&st->period_lock, flags);
+		hrtimer_start(&st->timer, period, HRTIMER_MODE_REL);
+	} else {
+		icp201xx_soft_reset(st);
+		hrtimer_cancel(&st->timer);
+	}
+
+	return 0;
+}
+
+static const struct iio_trigger_ops icp201xx_trigger_ops = {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+	.owner = THIS_MODULE,
+#endif
+	.set_trigger_state = icp201xx_trig_set_state,
+};
+
+
+static int icp201xx_read_raw(struct iio_dev *indio_dev,
+			    struct iio_chan_spec const *chan,
+			    int *val, int *val2, long mask)
+{
+	struct icp201xx_state *st = iio_priv(indio_dev);
+	uint8_t raw_buf[6] = {0,};
+	int ret;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_RAW:
+		mutex_lock(&indio_dev->mlock);
+		if (iio_buffer_enabled(indio_dev)) {
+			ret = -EBUSY;
+			goto out_info_raw;
+		}
+		ret = 0;
+		if (ret)
+			goto out_info_raw;
+
+		switch (chan->type) {
+		case IIO_PRESSURE:
+			icp201xx_reg_read_n(st, ICP201XX_REG_PRESS_DATA_0, 3, raw_buf);
+			*val = (int)(((raw_buf[2] & 0x0f) << 16) | (raw_buf[1] << 8) | raw_buf[0]);
+			if (*val & 0x080000 )
+				*val |= 0xFFF00000;
+
+			ret = IIO_VAL_INT;
+			break;
+		case IIO_TEMP:
+			icp201xx_reg_read_n(st, ICP201XX_REG_TEMP_DATA_0, 3, raw_buf);
+			*val = (int)(((raw_buf[2] & 0x0f) << 16) | (raw_buf[1] << 8) | raw_buf[0]);
+			if (*val & 0x080000 )
+				*val |= 0xFFF00000;
+
+			ret = IIO_VAL_INT;
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+		};
+out_info_raw:
+		mutex_unlock(&indio_dev->mlock);
+		break;
+	case IIO_CHAN_INFO_SCALE:
+		switch (chan->type) {
+		case IIO_PRESSURE:
+			*val = 1;
+			ret = IIO_VAL_INT;
+			break;
+		case IIO_TEMP:
+			*val = 1;
+			ret = IIO_VAL_INT;
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+		}
+		break;
+	case IIO_CHAN_INFO_OFFSET:
+		switch (chan->type) {
+		case IIO_PRESSURE:
+			*val = 0;
+			ret = IIO_VAL_INT;
+			break;
+		case IIO_TEMP:
+			*val = 0;
+			ret = IIO_VAL_INT;
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+		}
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static int icp201xx_validate_trigger(struct iio_dev *indio_dev,
+				    struct iio_trigger *trig)
+{
+	struct icp201xx_state *st = iio_priv(indio_dev);
+
+	if (st->trig != trig)
+		return -EINVAL;
+
+	return 0;
+}
+
+static ssize_t icp201xx_attr_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct icp201xx_state *st = iio_priv(dev_to_iio_dev(dev));
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+
+	switch (this_attr->address) {
+	case ICP201XX_ATTR_SAMP_AVAIL_FREQ:
+		return scnprintf(buf, PAGE_SIZE, "%u-%u\n", icp201xx_min_freq,
+				 icp201xx_max_freq[atomic_read(&st->mode)]);
+	case ICP201XX_ATTR_MODE:
+		return scnprintf(buf, PAGE_SIZE, "%d\n", atomic_read(&st->mode));
+	case ICP201XX_ATTR_CALIBDATA:
+		return scnprintf(buf, PAGE_SIZE, "0\n");
+	default:
+		return -EINVAL;
+	}
+}
+
+static ssize_t icp201xx_attr_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	struct iio_dev *indio_dev = dev_to_iio_dev(dev);
+	struct icp201xx_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	unsigned val;
+	int64_t min_period;
+	int ret;
+	unsigned long flags;
+
+	switch (this_attr->address) {
+	case ICP201XX_ATTR_MODE:
+		for (val = 0; val < ICP201XX_MODE_NB; ++val) {
+			if (sysfs_streq(buf, icp201xx_mode_strings[val]))
+				break;
+		}
+		if (val >= ICP201XX_MODE_NB)
+			return -EINVAL;
+
+		min_period = div_u64(NSEC_PER_SEC, icp201xx_max_freq[val]);
+
+		mutex_lock(&indio_dev->mlock);
+		if (!iio_buffer_enabled(indio_dev)) {
+			/* first ensure period is aligned with new mode */
+			spin_lock_irqsave(&st->period_lock, flags);
+			st->period = ns_to_ktime(min_period);
+			st->frequency = icp201xx_max_freq[val];
+			spin_unlock_irqrestore(&st->period_lock, flags);
+			/* switch mode */
+			atomic_set(&st->mode, val);
+			ret = 0;
+		} else {
+			ret = -EBUSY;
+		}
+		mutex_unlock(&indio_dev->mlock);
+		if (ret)
+			return ret;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return count;
+}
+
+static ssize_t icp201xx_period_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct icp201xx_state *st = iio_priv(dev_to_iio_dev(dev));
+	ktime_t period;
+	uint32_t period_us;
+	unsigned long flags;
+
+	spin_lock_irqsave(&st->period_lock, flags);
+	period = st->period;
+	spin_unlock_irqrestore(&st->period_lock, flags);
+	period_us = div_u64(ktime_to_ns(period), 1000UL);
+
+	return scnprintf(buf, PAGE_SIZE, "%lu\n", USEC_PER_SEC / period_us);
+}
+
+static ssize_t icp201xx_period_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	struct icp201xx_state *st = iio_priv(dev_to_iio_dev(dev));
+	int32_t sampling_frequency;
+	ktime_t period;
+	unsigned long flags;
+
+	if (kstrtoint(buf, 10, &sampling_frequency))
+		return -EINVAL;
+	if (sampling_frequency < icp201xx_min_freq ||
+			sampling_frequency > icp201xx_max_freq[atomic_read(&st->mode)])
+		return -EINVAL;
+
+	period = ns_to_ktime(div_u64(NSEC_PER_SEC, sampling_frequency));
+	spin_lock_irqsave(&st->period_lock, flags);
+	st->period = period;
+	st->frequency = sampling_frequency;
+	spin_unlock_irqrestore(&st->period_lock, flags);
+
+	if (hrtimer_active(&st->timer)) {
+		hrtimer_cancel(&st->timer);
+		hrtimer_start(&st->timer, period, HRTIMER_MODE_REL);
+	}
+
+	return count;
+}
+
+static IIO_DEV_ATTR_SAMP_FREQ(S_IRUGO | S_IWUSR, icp201xx_period_show,
+			      icp201xx_period_store);
+static IIO_DEVICE_ATTR(sampling_frequency_available, S_IRUGO, icp201xx_attr_show,
+		       NULL, ICP201XX_ATTR_SAMP_AVAIL_FREQ);
+static IIO_DEVICE_ATTR(mode, S_IRUGO | S_IWUSR, icp201xx_attr_show,
+		       icp201xx_attr_store, ICP201XX_ATTR_MODE);
+static IIO_DEVICE_ATTR(calibdata, S_IRUGO, icp201xx_attr_show, NULL,
+		       ICP201XX_ATTR_CALIBDATA);
+
+static struct attribute *icp201xx_attributes[] = {
+	&iio_dev_attr_sampling_frequency.dev_attr.attr,
+	&iio_dev_attr_sampling_frequency_available.dev_attr.attr,
+	&iio_dev_attr_mode.dev_attr.attr,
+	&iio_dev_attr_calibdata.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group icp201xx_attribute_group = {
+	.attrs = icp201xx_attributes,
+};
+
+static const struct iio_info icp201xx_info = {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+	.driver_module = THIS_MODULE,
+#endif
+	.read_raw = icp201xx_read_raw,
+	.attrs = &icp201xx_attribute_group,
+	.validate_trigger = icp201xx_validate_trigger,
+};
+
+static const struct iio_chan_spec icp201xx_channels[] = {
+	{
+		.type = IIO_PRESSURE,
+		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),
+		.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_OFFSET) |
+				BIT(IIO_CHAN_INFO_SCALE),
+		.scan_index = ICP201XX_CHANNEL_PRESSURE,
+		.scan_type = {
+			.sign = 'u',
+			.realbits = 24,
+			.storagebits = 32,
+			.shift = 8,
+			.endianness = IIO_BE,
+		},
+	}, {
+		.type = IIO_TEMP,
+		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),
+		.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_OFFSET) |
+				BIT(IIO_CHAN_INFO_SCALE),
+		.scan_index = ICP201XX_CHANNEL_TEMPERATURE,
+		.scan_type = {
+			.sign = 'u',
+			.realbits = 16,
+			.storagebits = 32,
+			.shift = 16,
+			.endianness = IIO_BE,
+		},
+	},
+	IIO_CHAN_SOFT_TIMESTAMP(ICP201XX_CHANNEL_TIMESTAMP),
+};
+
+static int icp201xx_probe(struct i2c_client *client,
+			 const struct i2c_device_id *id)
+{
+	struct iio_dev *indio_dev;
+	struct icp201xx_state *st;
+	int ret;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		dev_err(&client->dev, "plain i2c transactions not supported\n");
+		return -ENODEV;
+	}
+	/* has to be done before the first I2C communication */
+	crc8_populate_msb(icp201xx_crc8_table, ICP201XX_CRC8_POLYNOMIAL);
+
+	indio_dev = iio_device_alloc(&client->dev, sizeof(*st));
+	if (indio_dev == NULL) {
+		dev_err(&client->dev, "memory allocation failed\n");
+		return -ENOMEM;
+	}
+	i2c_set_clientdata(client, indio_dev);
+	indio_dev->dev.parent = &client->dev;
+	indio_dev->name = id->name;
+	indio_dev->channels = icp201xx_channels;
+	indio_dev->num_channels = ARRAY_SIZE(icp201xx_channels);
+	indio_dev->info = &icp201xx_info;
+
+	st = iio_priv(indio_dev);
+	st->client = client;
+	st->chip = id->driver_data;
+	hrtimer_init(&st->timer, CLOCK_BOOTTIME, HRTIMER_MODE_REL);
+	st->timer.function = icp201xx_timer_handler;
+	spin_lock_init(&st->period_lock);
+	atomic_set(&st->mode, ICP201XX_MODE_2);
+	st->period = ns_to_ktime(NSEC_PER_SEC / 40UL);
+	st->frequency = 40;
+
+	ret = icp201xx_init_chip(st);
+	if (ret) {
+		dev_err(&client->dev, "init chip error %d\n", ret);
+		pr_info("init chip error %d\n", ret);
+		goto error_free_device;
+	}
+
+	ret = iio_triggered_buffer_setup(indio_dev, NULL,
+					 icp201xx_read_measurement, NULL);
+	if (ret) {
+		dev_err(&client->dev, "iio triggered buffer error %d\n", ret);
+		goto error_free_device;
+	}
+
+	st->trig = iio_trigger_alloc("%s-dev%d", indio_dev->name,
+				     indio_dev->id);
+	if (st->trig == NULL) {
+		ret = -ENOMEM;
+		dev_err(&client->dev, "iio trigger alloc error\n");
+		goto error_free_buffer;
+	}
+	st->trig->dev.parent = &client->dev;
+	st->trig->ops = &icp201xx_trigger_ops;
+	iio_trigger_set_drvdata(st->trig, indio_dev);
+
+	ret = iio_trigger_register(st->trig);
+	if (ret) {
+		dev_err(&client->dev, "iio trigger register error %d\n", ret);
+		goto error_free_trigger;
+	}
+	iio_trigger_get(st->trig);
+	indio_dev->trig = st->trig;
+
+	ret = iio_device_register(indio_dev);
+	if (ret) {
+		dev_err(&client->dev, "iio device register error %d\n", ret);
+		goto error_unregister_trigger;
+	}
+
+	pr_info("ICP201xx probe done");
+	return 0;
+
+error_unregister_trigger:
+	iio_trigger_unregister(st->trig);
+error_free_trigger:
+	iio_trigger_free(st->trig);
+error_free_buffer:
+	iio_triggered_buffer_cleanup(indio_dev);
+error_free_device:
+	iio_device_free(indio_dev);
+	return ret;
+}
+
+static int icp201xx_remove(struct i2c_client *client)
+{
+	struct iio_dev *indio_dev = i2c_get_clientdata(client);
+	struct icp201xx_state *st = iio_priv(indio_dev);
+
+	iio_device_unregister(indio_dev);
+	iio_trigger_unregister(st->trig);
+	iio_trigger_free(st->trig);
+	iio_triggered_buffer_cleanup(indio_dev);
+	iio_device_free(indio_dev);
+
+	return 0;
+}
+
+static int icp201xx_suspend(struct device *dev)
+{
+	struct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));
+	struct icp201xx_state *st = iio_priv(indio_dev);
+
+	mutex_lock(&indio_dev->mlock);
+	if (iio_buffer_enabled(indio_dev))
+		hrtimer_cancel(&st->timer);
+	mutex_unlock(&indio_dev->mlock);
+
+	return 0;
+}
+
+static int icp201xx_resume(struct device *dev)
+{
+	struct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));
+	struct icp201xx_state *st = iio_priv(indio_dev);
+
+	mutex_lock(&indio_dev->mlock);
+	if (iio_buffer_enabled(indio_dev))
+		hrtimer_start(&st->timer, ns_to_ktime(0), HRTIMER_MODE_REL);
+	mutex_unlock(&indio_dev->mlock);
+
+	return 0;
+}
+
+static UNIVERSAL_DEV_PM_OPS(icp201xx_pm, icp201xx_suspend, icp201xx_resume, NULL);
+
+static const struct of_device_id icp201xx_of_match[] = {
+	{
+		.compatible = "invensense,icp201xx",
+		.data = (void *)ICP201XX,
+	},
+	{ }
+};
+MODULE_DEVICE_TABLE(of, icp201xx_of_match);
+
+static const struct i2c_device_id icp201xx_id[] = {
+	{ "icp201xx", ICP201XX },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, icp201xx_id);
+
+static struct i2c_driver icp201xx_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "icp201xx",
+		.pm = &icp201xx_pm,
+		.of_match_table = of_match_ptr(icp201xx_of_match),
+	},
+	.probe = icp201xx_probe,
+	.remove = icp201xx_remove,
+	.id_table = icp201xx_id,
+};
+module_i2c_driver(icp201xx_driver);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Invensense ICP201XX driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/iio/pressure/icp201xx.h b/drivers/iio/pressure/icp201xx.h
new file mode 100755
index 000000000..de65ad1cd
--- /dev/null
+++ b/drivers/iio/pressure/icp201xx.h
@@ -0,0 +1,128 @@
+#ifndef _INV_ICP201XX_H_
+#define _INV_ICP201XX_H_
+
+/********************************************
+Register Name: OTP Config 1
+Bank         : otp registers
+Register Type: READ/WRITE
+Register Address: 172 (Decimal); AC (Hex)
+********************************************/
+#define BIT_OTP_CONFIG1_WRITE_SWITCH_MASK			0x02
+#define BIT_OTP_CONFIG1_OTP_ENABLE_MASK				0x01
+#define BIT_OTP_CONFIG1_WRITE_SWITCH_POS			1
+
+/********************************************
+Register Name: OTP Debug2
+Bank         : OTP registers
+Register Type: READ/WRITE
+Register Address:  180(Decimal); BC (Hex)
+********************************************/
+#define BIT_OTP_DBG2_RESET_MASK   0x80
+#define BIT_OTP_DBG2_RESET_POS	  7
+
+/********************************************
+Register Name:
+Bank         : Main registers
+Register Type: READ/WRITE
+Register Address: 5(Decimal); 5 (Hex)
+********************************************/
+#define BIT_PEFE_OFFSET_TRIM_MASK			0x3F
+
+
+/********************************************
+Register Name:
+Bank         : Main registers
+Register Type: READ/WRITE
+Register Address: 6(Decimal); 6 (Hex)
+********************************************/
+#define BIT_HFOSC_OFFSET_TRIM_MASK			0x7F
+
+/********************************************
+Register Name:
+Bank         : Main registers
+Register Type: READ/WRITE
+Register Address: 7(Decimal); 7 (Hex)
+********************************************/
+#define BIT_PEFE_GAIN_TRIM_MASK			0x70
+#define BIT_PEFE_GAIN_TRIM_POS			4
+
+ /********************************************
+Register Name: DEVICE_STATUS
+Register Type: READ
+Register Address: 205 (Decimal); CD (Hex)
+********************************************/
+#define BIT_DEVICE_STATUS_LP_SEQ_STATE_MASK			0X06
+#define BIT_DEVICE_STATUS_MODE_SYNC_STATUS_MASK     0x01
+// 0 : Mode sync is going on, MODE_SELECT Reg is NOT accessible.
+// 1 : MODE_SELECT Reg is accessible.
+
+enum icp201xx_chip {
+	ICP201XX,
+};
+
+enum icp201xx_version {
+	ICP201XX_VERSION_A,
+	ICP201XX_VERSION_B
+};
+
+enum icp201xx_mode {
+	ICP201XX_MODE_0,
+	ICP201XX_MODE_1,
+	ICP201XX_MODE_2,
+	ICP201XX_MODE_3,
+	ICP201XX_MODE_4,
+	ICP201XX_MODE_NB,
+};
+
+/* ICP 201XX Operation Mode */
+typedef enum icp201xx_op_mode {
+	ICP201XX_OP_MODE0 = 0 ,  /* Mode 0: Bw:6.25 Hz ODR: 25Hz */
+	ICP201XX_OP_MODE1     ,  /* Mode 1: Bw:30 Hz ODR: 120Hz */
+	ICP201XX_OP_MODE2     ,  /* Mode 2: Bw:10 Hz ODR: 40Hz */
+	ICP201XX_OP_MODE3     ,  /* Mode 3: Bw:0.5 Hz ODR: 2Hz */
+	ICP201XX_OP_MODE4     ,  /* Mode 4: User configurable Mode */
+	ICP201XX_OP_MODE_MAX
+}icp201xx_op_mode_t;
+
+typedef enum icp201xx_forced_meas_trigger {
+	ICP201XX_FORCE_MEAS_STANDBY = 0,			/* Stay in Stand by */
+	ICP201XX_FORCE_MEAS_TRIGGER_FORCE_MEAS = 1	/* Trigger for forced measurements */
+}icp201xx_forced_meas_trigger_t;
+
+typedef enum icp201xx_meas_mode
+{
+	ICP201XX_MEAS_MODE_FORCED_TRIGGER = 0, /* Force trigger mode based on icp201xx_forced_meas_trigger_t **/
+	ICP201XX_MEAS_MODE_CONTINUOUS = 1   /* Continuous measurements based on selected mode ODR settings*/
+}icp201xx_meas_mode_t;
+
+typedef enum icp201xx_power_mode
+{
+	ICP201XX_POWER_MODE_NORMAL = 0,  /* Normal Mode: Device is in standby and goes to active mode during the execution of a measurement */
+	ICP201XX_POWER_MODE_ACTIVE = 1   /* Active Mode: Power on DVDD and enable the high frequency clock */
+}icp201xx_power_mode_t;
+
+
+typedef enum icp201xx_FIFO_readout_mode
+{
+	ICP201XX_FIFO_READOUT_MODE_PRES_TEMP = 0,   /* Pressure and temperature as pair and address wraps to the start address of the Pressure value ( pressure first ) */
+	ICP201XX_FIFO_READOUT_MODE_TEMP_ONLY = 1,   /* Temperature only reporting */
+	ICP201XX_FIFO_READOUT_MODE_TEMP_PRES = 2,   /* Pressure and temperature as pair and address wraps to the start address of the Temperature value ( Temperature first ) */
+	ICP201XX_FIFO_READOUT_MODE_PRES_ONLY = 3    /* Pressure only reporting */
+}icp201xx_FIFO_readout_mode_t;
+
+
+struct icp201xx_state {
+	struct i2c_client *client;
+	enum icp201xx_chip chip;
+	enum icp201xx_version version;
+	atomic_t mode;
+	struct iio_trigger *trig;
+	struct hrtimer timer;
+	ktime_t period;
+	uint16_t frequency;
+	spinlock_t period_lock;
+	enum icp201xx_FIFO_readout_mode fifo_readout_mode;
+};
+
+
+#endif
diff --git a/drivers/iio/pressure/icp201xx_core.c b/drivers/iio/pressure/icp201xx_core.c
new file mode 100755
index 000000000..2470305ed
--- /dev/null
+++ b/drivers/iio/pressure/icp201xx_core.c
@@ -0,0 +1,551 @@
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/sysfs.h>
+#include <linux/jiffies.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <linux/spinlock.h>
+#include <linux/spi/spi.h>
+#include <linux/i2c.h>
+#include <linux/version.h>
+
+#include "icp201xx.h"
+#include "icp201xx_core.h"
+#include "icp201xx_i2c.h"
+
+#define ICP201XX_MODE4_CONFIG_HFOSC_EN          0
+#define ICP201XX_MODE4_CONFIG_DVDD_EN           0
+#define ICP201XX_MODE4_CONFIG_IIR_EN            0
+#define ICP201XX_MODE4_CONFIG_FIR_EN            0
+#define ICP201XX_MODE4_CONFIG_IIR_K_FACTOR      1
+
+
+int icp201xx_mode_update(struct icp201xx_state *st, uint8_t mask, uint8_t pos, uint8_t new_value)
+{
+	int status;
+	uint8_t reg_value = 0;
+	uint8_t status_value = 0;
+
+	status = icp201xx_reg_read(st, ICP201XX_REG_MODE_SELECT, &reg_value);
+	if (status)
+		return status;
+
+	do {
+		status = icp201xx_reg_read(st, ICP201XX_REG_DEVICE_STATUS, &status_value);
+
+		if ( status )
+			return status;
+
+		if (status_value & BIT_DEVICE_STATUS_MODE_SYNC_STATUS_MASK)
+			break;
+
+		udelay(500);
+	}while(1);
+
+	reg_value = ( reg_value & (~mask) ) | ( new_value << pos) ;
+	status = icp201xx_reg_write(st, ICP201XX_REG_MODE_SELECT, reg_value);
+
+	return status;
+
+}
+
+int icp201xx_read_mode4_val(struct icp201xx_state *st, uint8_t reg_addr, uint8_t mask, uint8_t pos, uint8_t *value)
+{
+	int status;
+	uint8_t reg_value = 0;
+	status = icp201xx_reg_read(st, reg_addr, &reg_value);
+
+	if(status)
+		return status;
+
+	*value = (reg_value & mask) >> pos;
+
+	return status;
+}
+
+int icp201xx_get_mode4_config(struct icp201xx_state *st, uint8_t *pres_osr, uint8_t *temp_osr, uint16_t *odr, uint8_t *HFOSC_on,
+			      uint8_t *DVDD_on , uint8_t *IIR_filter_en, uint8_t *FIR_filter_en, uint16_t *IIR_k,
+			      uint8_t *pres_bs,uint8_t *temp_bs, uint16_t *press_gain)
+{
+	int status = 0;
+	uint8_t temp1,temp2;
+	/* OSR */
+	status |= icp201xx_reg_read(st, ICP201XX_REG_MODE4_OSR_PRESS, pres_osr);
+	status |= icp201xx_read_mode4_val(st, ICP201XX_REG_MODE4_CONFIG1, BIT_MODE4_CONFIG1_OSR_TEMP_MASK, 0, temp_osr);
+
+	/* ODR */
+	status |= icp201xx_reg_read(st, ICP201XX_REG_MODE4_ODR_LSB, &temp1);
+	status |= icp201xx_read_mode4_val(st, ICP201XX_REG_MODE4_CONFIG2, BIT_MODE4_CONFIG2_ODR_MSB_MASK, 0, &temp2);
+	*odr = (uint16_t) ((temp2 << 8) | temp1 );
+
+	/* IIR */
+	status |= icp201xx_read_mode4_val(st, ICP201XX_REG_MODE4_CONFIG1, BIT_MODE4_CONFIG1_IIR_EN_MASK, BIT_MODE4_CONFIG1_IIR_EN_POS, IIR_filter_en);
+	status |= icp201xx_reg_read(st, ICP201XX_REG_IIR_K_FACTOR_LSB, &temp1);
+	status |= icp201xx_reg_read(st, ICP201XX_REG_IIR_K_FACTOR_MSB, &temp2);
+	*IIR_k = (uint16_t) ((temp2 << 8) | temp1 );
+	/* FIR */
+	status |= icp201xx_read_mode4_val(st, ICP201XX_REG_MODE4_CONFIG1, BIT_MODE4_CONFIG1_FIR_EN_MASK, BIT_MODE4_CONFIG1_FIR_EN_POS, FIR_filter_en);
+
+	/* dvdd */
+	status |= icp201xx_read_mode4_val(st, ICP201XX_REG_MODE4_CONFIG2, BIT_MODE4_CONFIG2_DVDD_ON_MASK, BIT_MODE4_CONFIG2_DVDD_ON_POS, DVDD_on);
+
+	/* dfosc */
+	status |= icp201xx_read_mode4_val(st, ICP201XX_REG_MODE4_CONFIG2, BIT_MODE4_CONFIG2_HFOSC_ON_MASK, BIT_MODE4_CONFIG2_HFOSC_ON_POS, HFOSC_on);
+
+	/* Barrel Shifter */
+	status |= icp201xx_read_mode4_val(st, ICP201XX_REG_MODE4_BS_VALUE, BIT_MODE4_BS_VALUE_PRESS, 0, pres_bs);
+	status |= icp201xx_read_mode4_val(st, ICP201XX_REG_MODE4_BS_VALUE, BIT_MODE4_BS_VALUE_TEMP, 4, temp_bs);
+
+	/* Gain Factor */
+	icp201xx_reg_read(st, ICP201XX_REG_MODE4_PRESS_GAIN_FACTOR_LSB, &temp1);
+	icp201xx_reg_read(st, ICP201XX_REG_MODE4_PRESS_GAIN_FACTOR_MSB, &temp2);
+	*press_gain = (uint16_t) ((temp2 << 8) | temp1 );	
+
+	return status;
+}
+
+int icp201xx_set_mode4_config(struct icp201xx_state *st, uint8_t pres_osr, uint8_t temp_osr, uint16_t odr, uint8_t HFOSC_on, 
+			      uint8_t DVDD_on , uint8_t IIR_filter_en, uint8_t FIR_filter_en, uint16_t IIR_k,
+			      uint8_t pres_bs,uint8_t temp_bs, uint16_t press_gain)
+{
+	int status = 0;
+
+	status |= icp201xx_mode_update(st, BIT_POWER_MODE_MASK, BIT_FORCED_POW_MODE_POS, ICP201XX_POWER_MODE_ACTIVE);
+	msleep(2);
+
+	/* OSR */
+	status |= icp201xx_reg_write(st, ICP201XX_REG_MODE4_OSR_PRESS, pres_osr);
+	status |= icp201xx_reg_update(st, ICP201XX_REG_MODE4_CONFIG1, BIT_MODE4_CONFIG1_OSR_TEMP_MASK, 0, temp_osr);
+
+	/* ODR */
+	status |= icp201xx_reg_write(st, ICP201XX_REG_MODE4_ODR_LSB, (uint8_t)(0xFF & odr));
+	status |= icp201xx_reg_update(st, ICP201XX_REG_MODE4_CONFIG2, BIT_MODE4_CONFIG2_ODR_MSB_MASK, 0, (uint8_t)(0x1F & (odr >> 8))); 
+
+	/* IIR */
+	status |= icp201xx_reg_update(st, ICP201XX_REG_MODE4_CONFIG1, BIT_MODE4_CONFIG1_IIR_EN_MASK, BIT_MODE4_CONFIG1_IIR_EN_POS, IIR_filter_en);
+	status |= icp201xx_reg_write(st, ICP201XX_REG_IIR_K_FACTOR_LSB, (uint8_t)(IIR_k & 0xFF));
+	status |= icp201xx_reg_write(st, ICP201XX_REG_IIR_K_FACTOR_MSB, (uint8_t)((IIR_k >>8) & 0xFF));
+
+	/* FIR */
+	status |= icp201xx_reg_update(st, ICP201XX_REG_MODE4_CONFIG1, BIT_MODE4_CONFIG1_FIR_EN_MASK, BIT_MODE4_CONFIG1_FIR_EN_POS, FIR_filter_en);
+
+	/* dvdd */
+	status |= icp201xx_reg_update(st, ICP201XX_REG_MODE4_CONFIG2, BIT_MODE4_CONFIG2_DVDD_ON_MASK, BIT_MODE4_CONFIG2_DVDD_ON_POS, DVDD_on);
+
+	/* dfosc */
+	status |= icp201xx_reg_update(st, ICP201XX_REG_MODE4_CONFIG2, BIT_MODE4_CONFIG2_HFOSC_ON_MASK, BIT_MODE4_CONFIG2_HFOSC_ON_POS, HFOSC_on);
+
+	/* Barrel Shifter */
+	status |= icp201xx_reg_update(st, ICP201XX_REG_MODE4_BS_VALUE, BIT_MODE4_BS_VALUE_PRESS, 0, pres_bs);
+	status |= icp201xx_reg_update(st, ICP201XX_REG_MODE4_BS_VALUE, BIT_MODE4_BS_VALUE_TEMP, 4, temp_bs);
+
+	/* Pressure gain factor */
+	status |= icp201xx_reg_write(st, ICP201XX_REG_MODE4_PRESS_GAIN_FACTOR_LSB, (uint8_t)( press_gain & 0xFF ));
+	status |= icp201xx_reg_write(st, ICP201XX_REG_MODE4_PRESS_GAIN_FACTOR_MSB, (uint8_t)( (press_gain >> 8) & 0xFF ));
+
+	return status;
+}
+
+int icp201xx_flush_fifo(struct icp201xx_state *st)
+{
+	int status;
+	uint8_t read_val = 0;
+
+	status = icp201xx_reg_read(st, ICP201XX_REG_FIFO_FILL, &read_val);
+	if ( status )
+		return status;
+
+	read_val |= 0x80;
+	status = icp201xx_reg_write(st, ICP201XX_REG_FIFO_FILL, read_val);
+
+	return status;
+}
+
+int icp201xx_get_fifo_count(struct icp201xx_state *st, uint8_t *fifo_cnt)
+{
+	int status;
+	uint8_t read_val = 0;
+
+	status = icp201xx_reg_read(st, ICP201XX_REG_FIFO_FILL, &read_val);
+	if ( status )
+		return status;
+
+	*fifo_cnt = (uint8_t)( read_val & BIT_FIFO_LEVEL_MASK ) ;
+	/*Max value for fifo level is 0x10 for any values higher than 0x10 function sthould return error */
+	if (( *fifo_cnt & 0x10 )  && ( *fifo_cnt & 0x0F) )
+		status = -1;
+
+	return status;
+}
+EXPORT_SYMBOL_GPL(icp201xx_get_fifo_count);
+
+int icp201xx_get_fifo_data(struct icp201xx_state *st,uint8_t req_packet_cnt, uint8_t *data)
+{
+	uint8_t fifo_read_offset = ((st->fifo_readout_mode == ICP201XX_FIFO_READOUT_MODE_PRES_ONLY )||
+				    (st->fifo_readout_mode == ICP201XX_FIFO_READOUT_MODE_TEMP_ONLY)) ? 3 : 0;
+	uint8_t packet_cnt = req_packet_cnt * 2 * 3 ;
+
+	return icp201xx_reg_read_n(st, (ICP201XX_REG_PRESS_DATA_0 + fifo_read_offset), packet_cnt, data);
+}
+EXPORT_SYMBOL_GPL(icp201xx_get_fifo_data);
+
+int icp201xx_read_dummy_data(struct icp201xx_state *st)
+{
+	uint8_t dummy_data;
+
+	return icp201xx_reg_read_n(st, 0x00, 1, &dummy_data);
+}
+EXPORT_SYMBOL_GPL(icp201xx_read_dummy_data);
+
+int icp201xx_set_press_notification_config(struct icp201xx_state *st, uint8_t press_int_mask,int16_t press_abs , int16_t press_delta)
+{
+	uint8_t reg_value = 0;
+	int status = 0;
+
+	status |= icp201xx_reg_read(st, ICP201XX_REG_INTERRUPT_MASK, &reg_value);
+
+	reg_value =  (reg_value |  (ICP201XX_INT_MASK_PRESS_ABS | ICP201XX_INT_MASK_PRESS_DELTA)) & ~press_int_mask;
+
+	status |= icp201xx_reg_write(st, ICP201XX_REG_INTERRUPT_MASK, reg_value);
+
+	if (press_int_mask & ICP201XX_INT_MASK_PRESS_ABS) {
+		status |= icp201xx_reg_write(st, ICP201XX_REG_PRESS_ABS_LSB, (uint8_t)(press_abs & 0xff));
+		status |= icp201xx_reg_write(st, ICP201XX_REG_PRESS_ABS_MSB, (uint8_t)((press_abs >> 8) & 0xff));
+	}
+	else {
+		status |= icp201xx_reg_write(st, ICP201XX_REG_PRESS_ABS_LSB, 0x00);
+		status |= icp201xx_reg_write(st, ICP201XX_REG_PRESS_ABS_MSB, 0x00);
+	}
+
+	if (press_int_mask & ICP201XX_INT_MASK_PRESS_DELTA) {
+		status |= icp201xx_reg_write(st, ICP201XX_REG_PRESS_DELTA_LSB, (uint8_t)(press_delta & 0xff));
+		status |= icp201xx_reg_write(st, ICP201XX_REG_PRESS_DELTA_MSB, (uint8_t)((press_delta >> 8) & 0xff));
+	}
+	else {
+		status |= icp201xx_reg_write(st, ICP201XX_REG_PRESS_DELTA_LSB, 0);
+		status |= icp201xx_reg_write(st, ICP201XX_REG_PRESS_DELTA_MSB, 0);
+	}
+
+	return status;
+}
+
+int icp201xx_get_press_notification_config(struct icp201xx_state *st, uint8_t *press_int_mask,int16_t *press_abs , int16_t *press_delta)
+{
+	uint8_t reg_value = 0,lsb=0,msb=0;
+	int status = 0;
+
+	status |= icp201xx_reg_read(st, ICP201XX_REG_INTERRUPT_MASK, &reg_value);
+	*press_int_mask = reg_value & (ICP201XX_INT_MASK_PRESS_ABS | ICP201XX_INT_MASK_PRESS_DELTA);
+	status |= icp201xx_reg_read(st, ICP201XX_REG_PRESS_ABS_LSB, &lsb);
+	status |= icp201xx_reg_read(st, ICP201XX_REG_PRESS_ABS_MSB, &msb);
+	*press_abs = (msb << 8) | lsb ;
+	status |= icp201xx_reg_read(st, ICP201XX_REG_PRESS_DELTA_LSB, &lsb);
+	status |= icp201xx_reg_read(st, ICP201XX_REG_PRESS_DELTA_MSB, &msb);
+	*press_delta = (msb << 8) | lsb ;
+
+	return status;
+}
+
+int icp201xx_set_fifo_notification_config(struct icp201xx_state *st, uint8_t fifo_int_mask, uint8_t fifo_wmk_high,uint8_t fifo_wmk_low)
+{
+	uint8_t reg_value = 0;
+	int status = 0;
+
+	if ( fifo_wmk_high > 0xf || fifo_wmk_low > 0xf )
+		return 0;
+
+	/** FIFO config **/
+	reg_value = (fifo_wmk_high << 4) | fifo_wmk_low;
+	status |= icp201xx_reg_write(st, ICP201XX_REG_FIFO_CONFIG, reg_value);
+	status |= icp201xx_reg_read(st, ICP201XX_REG_INTERRUPT_MASK, &reg_value);
+	reg_value =  (reg_value |  (ICP201XX_INT_MASK_FIFO_WMK_HIGH | ICP201XX_INT_MASK_FIFO_OVER_FLOW |ICP201XX_INT_MASK_FIFO_WMK_LOW |ICP201XX_INT_MASK_FIFO_UNDER_FLOW)) & ~fifo_int_mask;
+	status |= icp201xx_reg_write(st, ICP201XX_REG_INTERRUPT_MASK, reg_value);
+
+	return status;
+}
+
+int icp201xx_get_fifo_notification_config(struct icp201xx_state *st,uint8_t *fifo_int_mask, uint8_t *fifo_wmk_high,uint8_t *fifo_wmk_low)
+{
+	uint8_t reg_value = 0;
+	int status = 0;
+
+	status |= icp201xx_reg_read(st, ICP201XX_REG_FIFO_CONFIG, &reg_value);
+
+	*fifo_wmk_low = (reg_value ) & 0x0f ;
+	*fifo_wmk_high = (reg_value >> 4) & 0x0f ;
+
+	status |= icp201xx_reg_read(st, ICP201XX_REG_INTERRUPT_MASK, &reg_value);
+
+	*fifo_int_mask = reg_value  & (ICP201XX_INT_MASK_FIFO_WMK_HIGH | ICP201XX_INT_MASK_FIFO_OVER_FLOW |ICP201XX_INT_MASK_FIFO_WMK_LOW |ICP201XX_INT_MASK_FIFO_UNDER_FLOW ) ;
+
+	return status;
+}
+
+int icp201xx_soft_reset(struct icp201xx_state *st)
+{
+	int status = 0;
+	uint8_t int_status;
+
+	status |= icp201xx_mode_update(st, 0xFF, 0, 0);
+	msleep(2);
+
+	status |= icp201xx_flush_fifo(st);
+	status |= icp201xx_set_fifo_notification_config(st ,0,0,0);
+
+	status |= icp201xx_reg_write(st, ICP201XX_REG_INTERRUPT_MASK, 0xFF);
+	status |= icp201xx_reg_read(st, ICP201XX_REG_INTERRUPT_STATUS, &int_status);
+	if (int_status )
+		status |= icp201xx_reg_write(st, ICP201XX_REG_INTERRUPT_STATUS, int_status);
+
+	return status;
+}
+EXPORT_SYMBOL_GPL(icp201xx_soft_reset);
+
+int icp201xx_app_pre_start_config(struct icp201xx_state *st, icp201xx_op_mode_t op_mode, icp201xx_meas_mode_t meas_mode, uint16_t odr_hz)
+{
+	uint8_t pres_bs = 0, temp_bs = 0;
+	uint16_t press_gain;
+	uint32_t temp1, temp2, press_gain_32bit;
+	uint8_t fir_en = 0;
+	uint16_t odr_set = 0;
+	uint8_t max_idx = 0;
+	int i = 0;
+	int icp201xx_mode4_config_press_osr_val = 0;
+
+	uint8_t m4_default_pres_osr, m4_default_temp_osr, m4_default_HFOSC_on, m4_default_DVDD_on, m4_default_IIR_filter_en, m4_default_FIR_filter_en,m4_default_pres_bs,m4_default_temp_bs;
+	uint16_t m4_default_odr =0,m4_default_IIR_k = 0, m4_default_press_gain =0;
+	int pres_bs_cond[] = {8192, 5793, 4096, 2896, 2048, 1448, 1024, 724, 512, 362, 256, 181, 128, 91, 64, 45, 32};
+
+	if (op_mode != ICP201XX_OP_MODE4)
+		return -1;
+
+	if (st->version == ICP201XX_VERSION_A)
+		max_idx = 8;
+	else
+		max_idx = 15;
+
+	icp201xx_get_mode4_config(st, &m4_default_pres_osr, &m4_default_temp_osr, &m4_default_odr, &m4_default_HFOSC_on, &m4_default_DVDD_on , 
+				  &m4_default_IIR_filter_en, &m4_default_FIR_filter_en, &m4_default_IIR_k,&m4_default_pres_bs,&m4_default_temp_bs,&m4_default_press_gain);
+
+	/** calculate gain factor from default m4 config **/
+	icp201xx_mode4_config_press_osr_val = (ICP201XX_MODE4_CONFIG_PRESS_OSR + 1 ) << 5;
+	do {
+		for (i = max_idx; i >= 0; i--) {
+			if (icp201xx_mode4_config_press_osr_val <= pres_bs_cond[i]) {
+				pres_bs = i;
+				break;
+			}
+		}
+	} while(0);
+
+	if (ICP201XX_MODE4_CONFIG_TEMP_OSR == 0x31) {
+		if (st->version == ICP201XX_VERSION_A)
+			temp_bs = 6;
+		else
+			temp_bs = 7;
+	} else {
+		if (st->version == ICP201XX_VERSION_A)
+			temp_bs = 8;
+		else
+			temp_bs = 9;
+	}
+
+	temp1 = (uint32_t)((m4_default_pres_osr + 1) * (m4_default_pres_osr + 1) * (1 << m4_default_pres_bs));
+	temp2 = (uint32_t)((ICP201XX_MODE4_CONFIG_PRESS_OSR + 1) * (ICP201XX_MODE4_CONFIG_PRESS_OSR + 1) * (1 << pres_bs));
+	press_gain_32bit = ((temp1<<14) / temp2);
+	press_gain_32bit *= m4_default_press_gain;
+	press_gain_32bit >>= 14;
+
+	press_gain = (uint16_t)press_gain_32bit;
+
+	odr_set = (8000 / odr_hz) - 1;
+
+	// set Mode4 config
+	return icp201xx_set_mode4_config(st,
+			 ICP201XX_MODE4_CONFIG_PRESS_OSR,
+			 ICP201XX_MODE4_CONFIG_TEMP_OSR,
+			 odr_set,//ICP201XX_MODE4_CONFIG_ODR_SETTING,
+			 ICP201XX_MODE4_CONFIG_HFOSC_EN,
+			 ICP201XX_MODE4_CONFIG_DVDD_EN,
+			 ICP201XX_MODE4_CONFIG_IIR_EN,
+			 fir_en,
+			 ICP201XX_MODE4_CONFIG_IIR_K_FACTOR,pres_bs,temp_bs,press_gain);
+}
+
+/*ICP201xx warm up.
+ *If FIR filter is enabled, it will cause a stettling effect on the first 14 pressure values.
+ *Therefore the first 14 pressure output values are discarded.
+ **/
+static void icp201xx_app_warmup(struct icp201xx_state *st, icp201xx_op_mode_t op_mode, icp201xx_meas_mode_t meas_mode)
+{
+	uint8_t fifo_packets = 0;
+	uint8_t fifo_packets_to_skip = 14;
+	uint8_t status;
+	uint8_t pres_osr, temp_osr,  HFOSC_on,	DVDD_on , IIR_filter_en, FIR_filter_en,pres_bs,temp_bs;
+	uint16_t odr =0,IIR_k = 0, press_gain =0;
+
+	if ( op_mode == ICP201XX_OP_MODE4)
+	{
+		icp201xx_get_mode4_config(st, &pres_osr, &temp_osr, &odr, &HFOSC_on, &DVDD_on , &IIR_filter_en, &FIR_filter_en, &IIR_k,&pres_bs,&temp_bs,&press_gain);
+		if(!FIR_filter_en)
+			fifo_packets_to_skip = 1;
+	}
+
+	do{
+		fifo_packets = 0;
+		if ( !icp201xx_get_fifo_count(st, &fifo_packets) && ( fifo_packets >= fifo_packets_to_skip ) ) {
+			icp201xx_flush_fifo(st);
+			icp201xx_reg_read(st, ICP201XX_REG_INTERRUPT_STATUS, &status);
+			if (status)
+				icp201xx_reg_write(st, ICP201XX_REG_INTERRUPT_STATUS, status); // Clear interrupt status
+			break;
+		}
+		udelay(2);
+	} while (1);
+}
+
+int icp201xx_config(struct icp201xx_state *st, icp201xx_op_mode_t op_mode, icp201xx_FIFO_readout_mode_t fifo_read_mode)
+{
+	uint8_t reg_value = 0;
+	int status = 0;
+
+	if ( op_mode >= ICP201XX_OP_MODE_MAX )
+		return -1;
+
+	status |= icp201xx_mode_update(st, 0xFF, 0, reg_value);
+	status |= icp201xx_flush_fifo(st);
+	status |= icp201xx_reg_read(st, ICP201XX_REG_INTERRUPT_STATUS, &reg_value);
+	if ( reg_value )
+		status |= icp201xx_reg_write(st, ICP201XX_REG_INTERRUPT_STATUS, reg_value);
+
+	/** FIFO config **/
+	status |= icp201xx_mode_update(st, BIT_MEAS_MODE_MASK, BIT_FORCED_MEAS_MODE_POS, (uint8_t)ICP201XX_MEAS_MODE_CONTINUOUS);
+	status |= icp201xx_mode_update(st, BIT_FORCED_MEAS_TRIGGER_MASK, BIT_FORCED_MEAS_TRIGGER_POS, (uint8_t)ICP201XX_FORCE_MEAS_STANDBY);
+	status |= icp201xx_mode_update(st, BIT_POWER_MODE_MASK, BIT_FORCED_POW_MODE_POS, ICP201XX_POWER_MODE_NORMAL);
+	status |= icp201xx_mode_update(st, BIT_FIFO_READOUT_MODE_MASK, 0, fifo_read_mode);
+	status |= icp201xx_mode_update(st, BIT_MEAS_CONFIG_MASK, BIT_MEAS_CONFIG_POS, (uint8_t)op_mode);
+
+	st->fifo_readout_mode = fifo_read_mode;
+
+	return status;
+}
+EXPORT_SYMBOL_GPL(icp201xx_config);
+
+void inv_run_icp201xx_in_polling(struct icp201xx_state *st, icp201xx_op_mode_t op_mode, uint16_t odr_hz)
+{
+	int status;
+
+	status = icp201xx_soft_reset(st);
+	if ( status )
+		pr_info("Soft Reset Error %d",status);
+
+	icp201xx_app_pre_start_config(st,op_mode,ICP201XX_MEAS_MODE_CONTINUOUS, odr_hz);
+	/*Configure for polling **/
+	icp201xx_set_fifo_notification_config(st, 0 ,0,0);
+
+	status = icp201xx_config(st,op_mode, ICP201XX_FIFO_READOUT_MODE_PRES_TEMP);
+	if ( status ) {
+		pr_info("ICP201xx config to run %d mode Error %d",op_mode,status);
+		return ;
+	}
+
+	pr_info("### Starting in Polling Mode for ODR_HZ %d stec Op Mode:%d ###",odr_hz, op_mode);
+	icp201xx_app_warmup(st, op_mode,ICP201XX_MEAS_MODE_CONTINUOUS);
+	pr_info("Polling Mode Set Done");
+}
+EXPORT_SYMBOL_GPL(inv_run_icp201xx_in_polling);
+
+static int icp201xx_enable_write_switch_OTP_read(struct icp201xx_state *st)
+{
+	int status = 0;
+
+	status |= icp201xx_mode_update(st, 0xFF, 0, 0x00);
+	msleep(2);
+
+	status |= icp201xx_mode_update(st, 0xFF, 0, BIT_POWER_MODE_MASK);
+	msleep(4);
+
+	status |= icp201xx_reg_write(st, ICP201XX_REG_MASTER_LOCK, 0x1f);
+	status |= icp201xx_reg_update(st, ICP201XX_REG_OTP_MTP_OTP_CFG1, BIT_OTP_CONFIG1_OTP_ENABLE_MASK, 0, 0x01);
+	status |= icp201xx_reg_update(st, ICP201XX_REG_OTP_MTP_OTP_CFG1, BIT_OTP_CONFIG1_WRITE_SWITCH_MASK, BIT_OTP_CONFIG1_WRITE_SWITCH_POS, 0x01);
+	udelay(10);
+
+	status |= icp201xx_reg_update(st, ICP201XX_REG_OTP_DEBUG2, BIT_OTP_DBG2_RESET_MASK, BIT_OTP_DBG2_RESET_POS, 0x01);
+	udelay(10);
+
+	status |= icp201xx_reg_update(st, ICP201XX_REG_OTP_DEBUG2, BIT_OTP_DBG2_RESET_MASK, BIT_OTP_DBG2_RESET_POS, 0x00);
+	udelay(10);
+
+	status |= icp201xx_reg_write(st, ICP201XX_REG_OTP_MTP_MRA_LSB, 0x04);
+	status |= icp201xx_reg_write(st, ICP201XX_REG_OTP_MTP_MRA_MSB, 0x04);
+	status |= icp201xx_reg_write(st, ICP201XX_REG_OTP_MTP_MRB_LSB, 0x21);
+	status |= icp201xx_reg_write(st, ICP201XX_REG_OTP_MTP_MRB_MSB, 0x20);
+	status |= icp201xx_reg_write(st, ICP201XX_REG_OTP_MTP_MR_LSB, 0x10);
+	status |= icp201xx_reg_write(st, ICP201XX_REG_OTP_MTP_MR_MSB, 0x80);
+
+	return status;
+}
+
+static int icp201xx_disable_write_switch_OTP_read(struct icp201xx_state *st)
+{
+	int status = 0;
+
+	status |= icp201xx_reg_update(st, ICP201XX_REG_OTP_MTP_OTP_CFG1, BIT_OTP_CONFIG1_OTP_ENABLE_MASK, 0, 0x00);
+	status |= icp201xx_reg_update(st, ICP201XX_REG_OTP_MTP_OTP_CFG1, BIT_OTP_CONFIG1_WRITE_SWITCH_MASK, BIT_OTP_CONFIG1_WRITE_SWITCH_POS, 0x00);
+	status |= icp201xx_mode_update(st, 0xFF, 0, 0x00);
+
+	return status;
+}
+
+static int icp201xx_read_otp_data(struct icp201xx_state *st, uint8_t otp_addr, uint8_t *val)
+{
+	uint8_t otp_status;
+	int status = 0;
+
+	icp201xx_reg_write(st, ICP201XX_REG_OTP_MTP_OTP_ADDR, otp_addr);
+	icp201xx_reg_write(st, ICP201XX_REG_OTP_MTP_OTP_CMD, 0x10);
+
+	do {
+		icp201xx_reg_read(st, ICP201XX_REG_OTP_MTP_OTP_STATUS, &otp_status);
+		if (status)
+			return -1;
+
+		if (otp_status == 0)
+			break;
+
+		udelay(1);
+	}while(1);
+
+	return icp201xx_reg_read(st, ICP201XX_REG_OTP_MTP_RD_DATA, val);
+}
+
+int icp201xx_OTP_bootup_cfg(struct icp201xx_state *st)
+{
+	int status = 0;
+	uint8_t offset = 0, gain = 0,Hfosc = 0;
+	icp201xx_enable_write_switch_OTP_read(st);
+
+	status |= icp201xx_read_otp_data(st, 0xF8, &offset);
+	status |= icp201xx_read_otp_data(st, 0xF9, &gain);
+	status |= icp201xx_read_otp_data(st, 0xFA, &Hfosc);
+
+	/** Updating main reg */
+	status |= icp201xx_reg_update(st, ICP201XX_REG_TRIM1_MSB, BIT_PEFE_OFFSET_TRIM_MASK, 0, offset & 0x3F);
+	status |= icp201xx_reg_update(st, ICP201XX_REG_TRIM2_MSB, BIT_PEFE_GAIN_TRIM_MASK, BIT_PEFE_GAIN_TRIM_POS, gain & 0x07);
+	status |= icp201xx_reg_update(st, ICP201XX_REG_TRIM2_LSB, BIT_HFOSC_OFFSET_TRIM_MASK, 0, Hfosc & 0x7F);
+
+	status |= icp201xx_disable_write_switch_OTP_read(st);
+	status |= icp201xx_reg_write(st, ICP201XX_REG_OTP_STATUS2, 0x01);
+
+	return status;
+}
+EXPORT_SYMBOL_GPL(icp201xx_OTP_bootup_cfg);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Invensense ICP201XX driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/iio/pressure/icp201xx_core.h b/drivers/iio/pressure/icp201xx_core.h
new file mode 100755
index 000000000..b0fc4ddbc
--- /dev/null
+++ b/drivers/iio/pressure/icp201xx_core.h
@@ -0,0 +1,506 @@
+/*
+ *________________________________________________________________________________________________________
+ *Copyright (c) 2017 InvenSense Inc. All rights reserved.
+ *
+ *This stoftware, related documentation and any modifications thereto (collectively 밪oftware? is stubject
+ *to InvenSense and its licensors' intellectual property rights under U.S. and international copyright
+ *and other intellectual property rights laws.
+ *
+ *InvenSense and its licensors retain all intellectual property and proprietary rights in and to the Software
+ *and any use, reproduction, disclosure or distribution of the Software without an express license agreement
+ *from InvenSense is sttrictly prohibited.
+ *
+ *EXCEPT AS OTHERWISE PROVIDED IN A LICENSE AGREEMENT BETWEEN THE PARTIES, THE SOFTWARE IS
+ *PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
+ *TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ *EXCEPT AS OTHERWISE PROVIDED IN A LICENSE AGREEMENT BETWEEN THE PARTIES, IN NO EVENT SHALL
+ *INVENSENSE BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, OR ANY
+ *DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
+ *NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ *OF THE SOFTWARE.
+ *________________________________________________________________________________________________________
+ */
+/**@defgroup DriverIcp201xx Icp201xx driver
+ *@brief    Low-level driver for Icp201xx devices
+ *@ingroup  DriverIcp201xx
+ *@{
+ */
+#ifndef _INV_ICP201XX_CORE_H_
+#define _INV_ICP201XX_DCORE_H_
+
+
+/*Main/ OTP Registers */
+#define ICP201XX_REG_TRIM1_MSB			0X05
+#define ICP201XX_REG_TRIM2_LSB			0X06
+#define ICP201XX_REG_TRIM2_MSB			0X07
+#define ICP201XX_REG_DEVICE_ID			0X0C
+#define ICP201XX_REG_OTP_MTP_OTP_CFG1		0XAC
+#define ICP201XX_REG_OTP_MTP_MR_LSB		0XAD
+#define ICP201XX_REG_OTP_MTP_MR_MSB		0XAE
+#define ICP201XX_REG_OTP_MTP_MRA_LSB		0XAF
+#define ICP201XX_REG_OTP_MTP_MRA_MSB		0XB0
+#define ICP201XX_REG_OTP_MTP_MRB_LSB		0XB1
+#define ICP201XX_REG_OTP_MTP_MRB_MSB		0XB2
+#define ICP201XX_REG_OTP_MTP_OTP_ADDR		0XB5
+#define ICP201XX_REG_OTP_MTP_OTP_CMD		0XB6
+#define ICP201XX_REG_OTP_MTP_RD_DATA		0XB8
+#define ICP201XX_REG_OTP_MTP_OTP_STATUS		0xB9
+#define ICP201XX_REG_OTP_DEBUG2			0XBC
+#define ICP201XX_REG_MASTER_LOCK		0XBE
+#define ICP201XX_REG_OTP_STATUS2		0xBF
+
+#define ICP201XX_REG_MODE_SELECT		0xC0
+#define ICP201XX_REG_INTERRUPT_STATUS		0xC1
+#define ICP201XX_REG_INTERRUPT_MASK		0xC2
+#define ICP201XX_REG_FIFO_CONFIG		0xC3
+#define ICP201XX_REG_FIFO_FILL			0xC4
+#define ICP201XX_REG_SPI_MODE			0xC5
+#define ICP201XX_REG_PRESS_ABS_LSB		0xC7
+#define ICP201XX_REG_PRESS_ABS_MSB		0xC8
+#define ICP201XX_REG_PRESS_DELTA_LSB		0xC9
+#define ICP201XX_REG_PRESS_DELTA_MSB		0xCA
+#define ICP201XX_REG_DEVICE_STATUS		0xCD
+#define ICP201XX_REG_I3C_INFO			0xCE
+#define ICP201XX_REG_VERSION			0XD3
+#define ICP201XX_REG_PRESS_DATA_0               0xFA
+#define ICP201XX_REG_PRESS_DATA_1               0xFB
+#define ICP201XX_REG_PRESS_DATA_2               0xFC
+#define ICP201XX_REG_TEMP_DATA_0                0xFD
+#define ICP201XX_REG_TEMP_DATA_1                0xFE
+#define ICP201XX_REG_TEMP_DATA_2                0xFF
+
+#define ICP201XX_REG_MODE0_OSR_PRESS		0X14
+#define ICP201XX_REG_MODE0_CFG1			0X15
+#define ICP201XX_REG_MODE0_ODR_LSB		0X16
+#define ICP201XX_REG_MODE0_CFG2			0X17
+#define ICP201XX_REG_MODE0_BS_VALUE		0X18
+
+#define ICP201XX_REG_MODE4_OSR_PRESS		(st->version == ICP201XX_VERSION_A)? 0x2C:0x3C
+#define ICP201XX_REG_MODE4_CONFIG1		(st->version == ICP201XX_VERSION_A)? 0x2D:0x3D
+#define ICP201XX_REG_MODE4_ODR_LSB		(st->version == ICP201XX_VERSION_A)? 0x2E:0x3E
+#define ICP201XX_REG_MODE4_CONFIG2		(st->version == ICP201XX_VERSION_A)? 0x2F:0x3F
+#define ICP201XX_REG_MODE4_BS_VALUE		(st->version == ICP201XX_VERSION_A)? 0x30:0x40
+#define ICP201XX_REG_IIR_K_FACTOR_LSB		(st->version == ICP201XX_VERSION_A)? 0x78:0x88
+#define ICP201XX_REG_IIR_K_FACTOR_MSB		(st->version == ICP201XX_VERSION_A)? 0x79:0x89
+
+#define ICP201XX_REG_MODE0_PRESS_GAIN_FACTOR_LSB	0x7A
+#define ICP201XX_REG_MODE0_PRESS_GAIN_FACTOR_MSG	0x7B
+#define ICP201XX_REG_MODE4_PRESS_GAIN_FACTOR_LSB	(st->version == ICP201XX_VERSION_A)? 0x82:0x92
+#define ICP201XX_REG_MODE4_PRESS_GAIN_FACTOR_MSB	(st->version == ICP201XX_VERSION_A)? 0x83:0x93
+
+#define ICP201XX_MODE4_CONFIG_PRESS_OSR         0xb1
+#define ICP201XX_MODE4_CONFIG_TEMP_OSR          0X0F
+/* odr_setting = ( 8000 / ODR in Hz ) -1  : 25 Hz => ODR setting = 320(0x140) **/
+#define ICP201XX_MODE4_CONFIG_ODR_SETTING       0x140 
+
+/********************************************
+Register Name: MODE4_CONFIG1
+Register Type: READ/WRITE
+Register Address: 45 (Decimal); 2D (Hex)
+********************************************/
+#define BIT_MODE4_CONFIG1_OSR_TEMP_MASK         0x1F
+#define BIT_MODE4_CONFIG1_FIR_EN_MASK		0x20
+#define BIT_MODE4_CONFIG1_IIR_EN_MASK		0x40
+
+#define BIT_MODE4_CONFIG1_FIR_EN_POS		5
+#define BIT_MODE4_CONFIG1_IIR_EN_POS		6
+
+/********************************************
+Register Name: MODE4_CONFIG2
+Register Type: READ/WRITE
+Register Address: 47 (Decimal); 2F (Hex)
+********************************************/
+#define BIT_MODE4_CONFIG2_ODR_MSB_MASK           0x1F
+#define BIT_MODE4_CONFIG2_DVDD_ON_MASK		 0x20
+#define BIT_MODE4_CONFIG2_HFOSC_ON_MASK		 0x40
+
+#define BIT_MODE4_CONFIG2_DVDD_ON_POS		5
+#define BIT_MODE4_CONFIG2_HFOSC_ON_POS		6
+/********************************************
+Register Name:
+Bank         : Main registers
+Register Type: READ/WRITE
+Register Address: 5(Decimal); 5 (Hex)
+********************************************/
+#define BIT_PEFE_OFFSET_TRIM_MASK		0x3F
+
+
+/********************************************
+Register Name:
+Bank         : Main registers
+Register Type: READ/WRITE
+Register Address: 48(Decimal); 30(Hex)
+********************************************/
+#define BIT_MODE4_BS_VALUE_PRESS		0x0F
+#define BIT_MODE4_BS_VALUE_TEMP			0XF0
+
+
+#define ICP201XX_INT_MASK_PRESS_DELTA      (0X01 << 6)
+#define ICP201XX_INT_MASK_PRESS_ABS        (0X01 << 5)
+#define ICP201XX_INT_MASK_FIFO_WMK_LOW     (0X01 << 3)
+#define ICP201XX_INT_MASK_FIFO_WMK_HIGH    (0X01 << 2)
+#define ICP201XX_INT_MASK_FIFO_UNDER_FLOW  (0X01 << 1)
+#define ICP201XX_INT_MASK_FIFO_OVER_FLOW   (0X01 << 0)	
+
+
+
+#define ICP201XX_INT_STATUS_PRESS_DELTA      (0X01 << 6)
+#define ICP201XX_INT_STATUS_PRESS_ABS        (0X01 << 5)
+#define ICP201XX_INT_STATUS_FIFO_WMK_LOW     (0X01 << 3)
+#define ICP201XX_INT_STATUS_FIFO_WMK_HIGH    (0X01 << 2)
+#define ICP201XX_INT_STATUS_FIFO_UNDER_FLOW  (0X01 << 1)
+#define ICP201XX_INT_STATUS_FIFO_OVER_FLOW   (0X01 << 0)
+
+
+int icp201xx_wr_pefe_offset_trim(struct icp201xx_state  *st,uint8_t new_value);
+
+
+/********************************************
+Register Name:
+Bank         : Main registers
+Register Type: READ/WRITE
+Register Address: 6(Decimal); 6 (Hex)
+********************************************/
+#define BIT_HFOSC_OFFSET_TRIM_MASK		0x7F
+
+int icp201xx_wr_hfosc_trim(struct icp201xx_state  *st,uint8_t new_value);
+
+/********************************************
+Register Name:
+Bank         : Main registers
+Register Type: READ/WRITE
+Register Address: 7(Decimal); 7 (Hex)
+********************************************/
+#define BIT_PEFE_GAIN_TRIM_MASK			0x70
+
+#define BIT_PEFE_GAIN_TRIM_POS			4
+
+int icp201xx_wr_pefe_gain_trim(struct icp201xx_state  *st, uint8_t new_value);
+
+/********************************************
+Register Name:
+Bank         : Main registers
+Register Type: READ/WRITE
+Register Address: 12(Decimal); 0X0C (Hex)
+********************************************/
+int icp201xx_rd_a1_who_am_i(struct icp201xx_state  *st, uint8_t *value);
+
+/********************************************
+Register Name: IIR_K_FACTOR_LSB
+Register Type: READ/WRITE
+Register Address: 120 (Decimal); 78 (Hex)
+********************************************/
+int icp201xx_wr_iir_k_factor_lsb(struct icp201xx_state  *st, uint8_t new_value);
+int icp201xx_rd_iir_k_factor_lsb(struct icp201xx_state *st, uint8_t *value);
+
+
+/********************************************
+Register Name: IIR_K_FACTOR_MSB
+Register Type: READ/WRITE
+Register Address: 121 (Decimal); 79 (Hex)
+********************************************/
+int icp201xx_wr_iir_k_factor_msb(struct icp201xx_state *st, uint8_t new_value);
+int icp201xx_rd_iir_k_factor_msb(struct icp201xx_state *st, uint8_t *value);
+
+
+/********************************************
+Register Name: OTP Config 1
+Bank         : otp registers
+Register Type: READ/WRITE
+Register Address: 172 (Decimal); AC (Hex)
+********************************************/
+#define BIT_OTP_CONFIG1_WRITE_SWITCH_MASK			0x02
+#define BIT_OTP_CONFIG1_OTP_ENABLE_MASK				0x01
+#define BIT_OTP_CONFIG1_WRITE_SWITCH_POS			1
+int icp201xx_wr_otp_write_switch(struct icp201xx_state  *st,uint8_t new_value);
+int icp201xx_wr_otp_enable(struct icp201xx_state  *st,uint8_t new_value);
+
+
+/********************************************
+Register Name: OTP MR LSB
+Bank         : otp registers
+Register Type: READ/WRITE
+Register Address: 173 (Decimal); AD (Hex)
+********************************************/
+int icp201xx_wr_otp_mr_lsb(struct icp201xx_state  *st,uint8_t new_value);
+
+/********************************************
+Register Name: OTP MR MSB
+Bank         : otp registers
+Register Type: READ/WRITE
+Register Address: 174 (Decimal); AE (Hex)
+********************************************/
+int icp201xx_wr_otp_mr_msb(struct icp201xx_state  *st,uint8_t new_value);
+/********************************************
+Register Name: OTP MRA LSB
+Bank         : otp registers
+Register Type: READ/WRITE
+Register Address: 175 (Decimal); AF (Hex)
+********************************************/
+int icp201xx_wr_otp_mra_lsb(struct icp201xx_state  *st,uint8_t new_value);
+int icp201xx_rd_otp_mra_lsb(struct icp201xx_state  *st, uint8_t *value);
+
+/********************************************
+Register Name: OTP MRA MSB
+Bank         : otp registers
+Register Type: READ/WRITE
+Register Address: 176 (Decimal); B0 (Hex)
+********************************************/
+int icp201xx_wr_otp_mra_msb(struct icp201xx_state  *st,uint8_t new_value);
+int icp201xx_rd_otp_mra_msb(struct icp201xx_state  *st, uint8_t *value);
+
+/********************************************
+Register Name: OTP MRB LSB
+Bank         : otp registers
+Register Type: READ/WRITE
+Register Address: 177 (Decimal); B1 (Hex)
+********************************************/
+int icp201xx_wr_otp_mrb_lsb(struct icp201xx_state  *st,uint8_t new_value);
+
+/********************************************
+Register Name: OTP MRB MSB
+Bank         : otp registers
+Register Type: READ/WRITE
+Register Address: 178 (Decimal); B2 (Hex)
+********************************************/
+int icp201xx_wr_otp_mrb_msb(struct icp201xx_state  *st,uint8_t new_value);
+
+/********************************************
+Register Name: OTP ADDR
+Bank         : otp registers
+Register Type: READ/WRITE
+Register Address: 181 (Decimal); B5 (Hex)
+********************************************/
+int icp201xx_wr_otp_addr(struct icp201xx_state  *st,uint8_t new_value);
+int icp201xx_rd_otp_addr(struct icp201xx_state  *st, uint8_t *value);
+
+/********************************************
+Register Name: OTP CMD
+Bank         : otp register
+Register Type: READ/WRITE
+Register Address: 182 (Decimal); B6 (Hex)
+********************************************/
+int icp201xx_wr_otp_cmd(struct icp201xx_state  *st,uint8_t new_value);
+int icp201xx_rd_otp_cmd(struct icp201xx_state  *st, uint8_t *value);
+
+
+/********************************************
+Register Name: OTP Read Reg
+Bank         : otp registers
+Register Type: READ/WRITE
+Register Address: 184 (Decimal); B8 (Hex)
+********************************************/
+int icp201xx_rd_otp_reg_data(struct icp201xx_state  *st, uint8_t *value);
+
+
+/********************************************
+Register Name: OTP sttatus
+Bank         : otp registers
+Register Type: READ/WRITE
+Register Address: 185 (Decimal); B9 (Hex)
+********************************************/
+int icp201xx_rd_otp_status(struct icp201xx_state  *st, uint8_t *value);
+
+/********************************************
+Register Name: OTP Debug2
+Bank         : OTP registers
+Register Type: READ/WRITE
+Register Address:  180(Decimal); BC (Hex)
+********************************************/
+#define BIT_OTP_DBG2_RESET_MASK   0x80
+#define BIT_OTP_DBG2_RESET_POS	  7
+
+int icp201xx_wr_otp_dbg2_reset(struct icp201xx_state  *st,uint8_t new_value);
+
+
+/********************************************
+Register Name: Master lock
+Bank         : OTP registers
+Register Type: READ/WRITE
+Register Address:  190(Decimal); BE (Hex)
+********************************************/
+int icp201xx_wr_master_lock(struct icp201xx_state  *st,uint8_t new_value);
+
+
+/********************************************
+Register Name: MODE_SELECT
+Register Type: READ/WRITE
+Register Address: 192 (Decimal); C0 (Hex)
+********************************************/
+#define BIT_MEAS_CONFIG_MASK          0xE0
+#define BIT_FORCED_MEAS_TRIGGER_MASK  0x10
+#define BIT_MEAS_MODE_MASK            0x08
+#define BIT_POWER_MODE_MASK           0x04
+#define BIT_FIFO_READOUT_MODE_MASK    0x03
+
+#define BIT_MEAS_CONFIG_POS		5
+#define BIT_FORCED_MEAS_TRIGGER_POS	4
+#define BIT_FORCED_MEAS_MODE_POS	3
+#define BIT_FORCED_POW_MODE_POS		2
+
+int icp201xx_wr_mode_select(struct icp201xx_state  *st, uint8_t new_value);
+int icp201xx_rd_mode_select(struct icp201xx_state *st, uint8_t *value);
+
+int icp201xx_wr_meas_config(struct icp201xx_state  *st, icp201xx_op_mode_t new_value);
+int icp201xx_rd_meas_config(struct icp201xx_state *st, icp201xx_op_mode_t *value);
+
+int icp201xx_wr_forced_meas_trigger(struct icp201xx_state  *st, icp201xx_forced_meas_trigger_t new_value);
+int icp201xx_rd_forced_meas_trigger(struct icp201xx_state *st, icp201xx_forced_meas_trigger_t *value);
+
+int icp201xx_wr_meas_mode(struct icp201xx_state  *st, icp201xx_meas_mode_t new_value);
+int icp201xx_rd_meas_mode(struct icp201xx_state *st, icp201xx_meas_mode_t *value);
+
+int icp201xx_wr_pow_mode(struct icp201xx_state  *st, icp201xx_power_mode_t new_value);
+int icp201xx_rd_pow_mode(struct icp201xx_state *st, icp201xx_power_mode_t *value);
+
+int icp201xx_wr_fifo_readout_mode(struct icp201xx_state  *st, icp201xx_FIFO_readout_mode_t new_value);
+int icp201xx_rd_fifo_readout_mode(struct icp201xx_state *st, icp201xx_FIFO_readout_mode_t *value);
+
+
+/********************************************
+Register Name: INTERRUPT_STATUS
+Register Type: READ/WRITE
+Register Address: 193 (Decimal); C1(Hex)
+********************************************/
+int icp201xx_wr_int_status(struct icp201xx_state *st, uint8_t new_value);
+
+int icp201xx_rd_int_status(struct icp201xx_state *st, uint8_t *value);
+
+/********************************************
+Register Name: INTERRUPT_MASK
+Register Type: READ/WRITE
+Register Address: 194 (Decimal); C2(Hex)
+********************************************/
+int icp201xx_wr_int_mask(struct icp201xx_state *st, uint8_t new_value);
+
+int icp201xx_rd_int_mask(struct icp201xx_state *st, uint8_t *value);
+
+/********************************************
+Register Name: FIFO_CONFIG
+Register Type: READ/WRITE
+Register Address: 195 (Decimal); C3(Hex)
+********************************************/
+#define BIT_FIFO_WM_HIGH_MASK    0xF0
+#define BIT_FIFO_WM_LOW_MASK     0x0F
+
+#define BIT_FIFO_WM_HIGH_POS     3
+
+int icp201xx_wr_fifo_config(struct icp201xx_state *st, uint8_t new_value);
+int icp201xx_rd_fifo_config(struct icp201xx_state *st, uint8_t *value);
+
+int icp201xx_wr_fifo_wm_high(struct icp201xx_state *st, uint8_t new_value);
+int icp201xx_rd_fifo_wm_high(struct icp201xx_state *st, uint8_t *value);
+
+int icp201xx_wr_fifo_wm_low(struct icp201xx_state *st, uint8_t new_value);
+int icp201xx_rd_fifo_wm_low(struct icp201xx_state *st, uint8_t *value);
+
+
+/********************************************
+Register Name: FIFO_FILL
+Register Type: READ/WRITE
+Register Address: 196 (Decimal); C4 (Hex)
+********************************************/
+#define BIT_FIFO_FLUSH_MASK		0x80
+#define BIT_FIFO_EMPTY_STATUS_MASK	0x40
+#define BIT_FIFO_FULL_STATUS_MASK	0x20
+#define BIT_FIFO_LEVEL_MASK		0x1F
+
+#define BIT_FIFO_EMPTY_POS     6
+#define BIT_FIFO_FULL_POS      5
+
+int icp201xx_wr_fifo_fill(struct icp201xx_state *st, uint8_t new_value);
+int icp201xx_rd_fifo_fill(struct icp201xx_state *st, uint8_t *value);
+
+
+int icp201xx_wr_flush_fifo(struct icp201xx_state *st);
+int icp201xx_rd_fifo_empty_status(struct icp201xx_state *st, uint8_t *value);
+int icp201xx_rd_fifo_full_status(struct icp201xx_state *st, uint8_t *value);
+int icp201xx_rd_fifo_level(struct icp201xx_state *st, uint8_t *value);
+
+/********************************************
+Register Name: SPI_MODE
+Register Type: READ/WRITE
+Register Address: 197 (Decimal); C5 (Hex)
+********************************************/
+typedef enum icp201xx_spi_mode {
+	ICP201XX_SPI_MODE_4_WIRE = 0,
+	ICP201XX_SPI_MODE_3_WIRE,
+}icp201xx_spi_mode_t;
+
+#define BIT_FIFO_SPI_MODE_MASK    0x01  
+                                 // 0: SPI 4-WIRE
+								 // 1: SPI 3-WIRE
+int icp201xx_wr_spi_mode(struct icp201xx_state *st, icp201xx_spi_mode_t new_value);
+int icp201xx_rd_spi_mode(struct icp201xx_state *st, icp201xx_spi_mode_t *value);
+
+/********************************************
+Register Name: PRESS_ABS_LSB
+Register Type: READ/WRITE
+Register Address: 199 (Decimal); C7 (Hex)
+********************************************/
+int icp201xx_wr_press_abs_lsb(struct icp201xx_state *st, uint8_t new_value);
+int icp201xx_rd_press_abs_lsb(struct icp201xx_state *st, uint8_t *value);
+/********************************************
+Register Name: PRESS_ABS_MSB
+Register Type: READ/WRITE
+Register Address: 200 (Decimal); C8 (Hex)
+********************************************/
+int icp201xx_wr_press_abs_msb(struct icp201xx_state *st, uint8_t new_value);
+int icp201xx_rd_press_abs_msb(struct icp201xx_state *st, uint8_t *value);
+/********************************************
+Register Name: PRESS_DELTA_LSB
+Register Type: READ/WRITE
+Register Address: 201 (Decimal); C9 (Hex)
+********************************************/
+int icp201xx_wr_press_delta_lsb(struct icp201xx_state *st, uint8_t new_value);
+int icp201xx_rd_press_delta_lsb(struct icp201xx_state *st, uint8_t *value);
+/********************************************
+Register Name: PRESS_DELTA_MSB
+Register Type: READ/WRITE
+Register Address: 202 (Decimal); CA (Hex)
+********************************************/
+int icp201xx_wr_press_delta_msb(struct icp201xx_state *st, uint8_t new_value);
+int icp201xx_rd_press_delta_msb(struct icp201xx_state *st, uint8_t *value);
+/********************************************
+Register Name: DEVICE_STATUS
+Register Type: READ
+Register Address: 205 (Decimal); CD (Hex)
+********************************************/
+#define BIT_DEVICE_STATUS_LP_SEQ_STATE_MASK		0X06
+#define BIT_DEVICE_STATUS_MODE_SYNC_STATUS_MASK		0x01
+// 0 : Mode stync is going on, MODE_SELECT Reg is NOT accessible.
+// 1 : MODE_SELECT Reg is accessible.
+
+#define BIT_DEVICE_STATUS_LP_SEQ_STATE_POS	1
+int icp201xx_rd_device_status(struct icp201xx_state *st, uint8_t *value);
+int icp201xx_rd_mode_sync_status(struct icp201xx_state *st, uint8_t *value);
+int icp201xx_rd_lp_seq_sync_status(struct icp201xx_state *st, uint8_t *value);
+
+/********************************************
+Register Name: SPI_MODE
+Register Type: READ/WRITE
+Register Address: 206 (Decimal); CE (Hex)
+********************************************/
+
+int icp201xx_rd_fifo(struct icp201xx_state *st, uint8_t len, uint8_t*value, uint8_t fifo_read_offset);
+
+/********************************************
+Register Name:
+Bank         : Main registers
+Register Type: READ/WRITE
+Register Address: 211(Decimal); 0XD3 (Hex)
+********************************************/
+
+int icp201xx_rd_b1_who_am_i(struct icp201xx_state  *st, uint8_t *value);
+
+int icp201xx_get_fifo_count(struct icp201xx_state *st, uint8_t *fifo_cnt);
+int icp201xx_get_fifo_data(struct icp201xx_state *st, uint8_t req_packet_cnt, uint8_t *data);
+int icp201xx_read_dummy_data(struct icp201xx_state *st);
+
+int icp201xx_soft_reset(struct icp201xx_state *st);
+int icp201xx_config(struct icp201xx_state *st, icp201xx_op_mode_t op_mode, icp201xx_FIFO_readout_mode_t fifo_read_mode);
+void inv_run_icp201xx_in_polling(struct icp201xx_state *st, icp201xx_op_mode_t op_mode, uint16_t odr_hz);
+int icp201xx_OTP_bootup_cfg(struct icp201xx_state *st);
+
+#endif  /*#ifndef _INV_ICP201XX_CORE_H_ */
+
diff --git a/drivers/iio/pressure/icp201xx_i2c.c b/drivers/iio/pressure/icp201xx_i2c.c
new file mode 100755
index 000000000..269696f8d
--- /dev/null
+++ b/drivers/iio/pressure/icp201xx_i2c.c
@@ -0,0 +1,158 @@
+/*
+ * ________________________________________________________________________________________________________
+ * Copyright (c) 2015-2015 InvenSense Inc. All rights reserved.
+ *
+ * This software, related documentation and any modifications thereto (collectively 밪oftware� is subject
+ * to InvenSense and its licensors' intellectual property rights under U.S. and international copyright
+ * and other intellectual property rights laws.
+ *
+ * InvenSense and its licensors retain all intellectual property and proprietary rights in and to the Software
+ * and any use, reproduction, disclosure or distribution of the Software without an express license agreement
+ * from InvenSense is strictly prohibited.
+ *
+ * EXCEPT AS OTHERWISE PROVIDED IN A LICENSE AGREEMENT BETWEEN THE PARTIES, THE SOFTWARE IS
+ * PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
+ * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * EXCEPT AS OTHERWISE PROVIDED IN A LICENSE AGREEMENT BETWEEN THE PARTIES, IN NO EVENT SHALL
+ * INVENSENSE BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, OR ANY
+ * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
+ * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THE SOFTWARE.
+ * ________________________________________________________________________________________________________
+ */
+
+/** @defgroup DriverIcp201xxSerif Icp201xx driver serif
+ *  @brief Interface for low-level serial (I2C/I3C/SPI) access
+ *  @ingroup  DriverIcp201xx
+ *  @{
+ */
+
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include "icp201xx_i2c.h"
+
+static inline int icp201xx_i2c_xfer(struct i2c_adapter *adap,
+		struct i2c_msg *msgs, int num)
+{
+	int ret;
+
+	ret = i2c_transfer(adap, msgs, num);
+	if (ret < 0)
+		return ret;
+
+	if (ret == num)
+		ret = 0;
+	else
+		ret = -EIO;
+
+	return ret;
+}
+
+int icp201xx_reg_write(struct icp201xx_state *st, u8 reg_addr, uint8_t val)
+{
+	int ret;
+
+
+	u8 buf[2];
+
+	struct i2c_msg msgs[1] = {
+		{
+			.addr = st->client->addr,
+			.flags = 0,
+			.len = 2,
+			.buf =(u8*)buf,
+		}
+	};
+
+	buf[0] = reg_addr & 0xFF;
+	buf[1] = val;
+
+
+	ret = icp201xx_i2c_xfer(st->client->adapter, &msgs[0], 1);
+	if (ret)
+		return ret;
+
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(icp201xx_reg_write);
+
+int icp201xx_reg_read(struct icp201xx_state *st, u8 reg_addr, u8 *val)
+{
+	int ret;
+
+	struct i2c_msg msgs[12] = {
+		{
+			.addr = st->client->addr,
+			.flags = 0,
+			.len = 1,
+			.buf =&reg_addr,
+		},
+		{
+			.addr = st->client->addr,
+			.flags = I2C_M_RD,
+			.len = 1,
+			.buf = (u8*)val,
+		},
+
+	};
+
+
+	ret = icp201xx_i2c_xfer(st->client->adapter, msgs, 2);
+	if (ret)
+		return ret;
+
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(icp201xx_reg_read);
+
+int icp201xx_reg_read_n(struct icp201xx_state *st, u8 reg_addr, u8 len, u8 *val)
+{
+        int ret;
+
+        struct i2c_msg msgs[12] = {
+                {
+                        .addr = st->client->addr,
+                        .flags = 0,
+                        .len = 1,
+                        .buf =&reg_addr,
+                },
+                {
+                        .addr = st->client->addr,
+                        .flags = I2C_M_RD,
+                        .len = len,
+                        .buf = (u8*)val,
+                },
+
+        };
+
+
+        ret = icp201xx_i2c_xfer(st->client->adapter, msgs, 2);
+        if (ret)
+                return ret;
+
+
+        return 0;
+}
+EXPORT_SYMBOL_GPL(icp201xx_reg_read_n);
+
+int icp201xx_reg_update(struct icp201xx_state *st, u8 reg_addr, u8 mask, u8 pos, u8 val)
+{
+	int ret;
+	uint8_t reg_value = 0;
+
+	ret = icp201xx_reg_read(st, reg_addr, &reg_value);
+
+	if(ret)
+		return ret;
+
+	reg_value = (reg_value & (~mask)) | (val << pos) ;
+
+	return icp201xx_reg_write(st, reg_addr, reg_value);
+}
+EXPORT_SYMBOL_GPL(icp201xx_reg_update);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Invensense ICP201XX driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/iio/pressure/icp201xx_i2c.h b/drivers/iio/pressure/icp201xx_i2c.h
new file mode 100755
index 000000000..c077d167d
--- /dev/null
+++ b/drivers/iio/pressure/icp201xx_i2c.h
@@ -0,0 +1,64 @@
+/*
+ * ________________________________________________________________________________________________________
+ * Copyright (c) 2015-2015 InvenSense Inc. All rights reserved.
+ *
+ * This software, related documentation and any modifications thereto (collectively 밪oftware� is subject
+ * to InvenSense and its licensors' intellectual property rights under U.S. and international copyright
+ * and other intellectual property rights laws.
+ *
+ * InvenSense and its licensors retain all intellectual property and proprietary rights in and to the Software
+ * and any use, reproduction, disclosure or distribution of the Software without an express license agreement
+ * from InvenSense is strictly prohibited.
+ *
+ * EXCEPT AS OTHERWISE PROVIDED IN A LICENSE AGREEMENT BETWEEN THE PARTIES, THE SOFTWARE IS
+ * PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
+ * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * EXCEPT AS OTHERWISE PROVIDED IN A LICENSE AGREEMENT BETWEEN THE PARTIES, IN NO EVENT SHALL
+ * INVENSENSE BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, OR ANY
+ * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
+ * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THE SOFTWARE.
+ * ________________________________________________________________________________________________________
+ */
+#ifndef _INV_ICP201XX_I2C_H_
+#define _INV_ICP201XX_I2C_H_
+
+#include "icp201xx.h"
+
+/** @brief Reads data from a register on mems.
+ * @param[in]  st Pointer to the driver context
+ * @param[in]  reg_addr    register address
+ * @param[out] val   output data from the register
+ * @return     0 in case of success, negative value on error. See enum inv_status
+ */
+int icp201xx_reg_read(struct icp201xx_state *st, u8 reg_addr, u8 *val);
+
+/** @brief Reads data from a register on mems.
+ * @param[in]  st Pointer to the driver context
+ * @param[in]  reg_addr    register address
+ * @param[out] val   output data from the register
+ * @return     0 in case of success, negative value on error. See enum inv_status
+ */
+int icp201xx_reg_read_n(struct icp201xx_state *st, u8 reg_addr, u8 len, u8 *val);
+
+/** @brief Writes data to a register on mems.
+ * @param[in]  st Pointer to the driver context
+ * @param[in]  reg_addr    register address
+ * @param[in]  val intput data to the register
+ * @return     0 in case of success, negative value on error. See enum inv_status
+ */
+int icp201xx_reg_write(struct icp201xx_state *st, u8 reg_addr, uint8_t val);
+
+/** @brief Update data to a register on mems.
+ * @param[in]  st Pointer to the driver context
+ * @param[in]  reg_addr    register address
+ * @param[in]  mask	bit mask for update register
+ * @param[in]  pos	bit shift for update register
+ * @param[in]  val intput data to the register
+ * @return     0 in case of success, negative value on error. See enum inv_status
+ */
+int icp201xx_reg_update(struct icp201xx_state *st, u8 reg_addr, u8 mask, u8 pos, u8 val);
+
+#endif /* _INV_ICP201XX_INTERFACE_H_ */
+
+
-- 
2.14.1

