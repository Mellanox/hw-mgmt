From 1bab6c37b2b003d073141d375669ce5d66e8fd7e Mon Sep 17 00:00:00 2001
From: Vadim Pasternak <vadimp@nvidia.com>
Date: Mon, 10 May 2021 21:14:03 +0300
Subject: [PATCH 3/3] mlxsw: Support extended capability for reading
 temperature

Currently these thresholds used to be obtained from Management Cable
Info Access Register (MCIA) by specifying the thresholds offsets within
transceiver EEPROM layout. These data do not pass validation and in
some cases could be not reliable, for example due to some problem with
transceiver module.

Add support for new feature provided by Management Temperature
Register, which allows reading and validation of transceivers
temperature thresholds.

Validate if MTMP supports temperature thresholds reading through the
value set in MTMP filed 'max_operational_temperature' - if it is not
zero, feature is supported.

Signed-off-by: Vadim Pasternak <vadimp@nvidia.com>
---
 .../ethernet/mellanox/mlxsw/core_thermal.c    | 29 ++++++++++++-------
 1 file changed, 18 insertions(+), 11 deletions(-)

diff --git a/drivers/net/ethernet/mellanox/mlxsw/core_thermal.c b/drivers/net/ethernet/mellanox/mlxsw/core_thermal.c
index b0ae4238d..80515ac46 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/core_thermal.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/core_thermal.c
@@ -165,24 +165,26 @@ mlxsw_thermal_module_trips_reset(struct mlxsw_thermal_module *tz)
 
 static int
 mlxsw_thermal_module_trips_update(struct device *dev, struct mlxsw_core *core,
-				  struct mlxsw_thermal_module *tz)
+				  struct mlxsw_thermal_module *tz, int crit_temp,
+				  int emerg_temp)
 {
-	int crit_temp, emerg_temp;
 	int err;
 
-	err = mlxsw_env_module_temp_thresholds_get(core, tz->slot_index,
+	if (!emerg_temp) {
+		err = mlxsw_env_module_temp_thresholds_get(core, tz->slot_index,
 						   tz->module,
 						   SFP_TEMP_HIGH_WARN,
 						   &crit_temp);
-	if (err)
-		return err;
+		if (err)
+			return err;
 
-	err = mlxsw_env_module_temp_thresholds_get(core, tz->slot_index,
+		err = mlxsw_env_module_temp_thresholds_get(core, tz->slot_index,
 						   tz->module,
 						   SFP_TEMP_HIGH_ALARM,
 						   &emerg_temp);
-	if (err)
-		return err;
+		if (err)
+			return err;
+	}
 
 	if (crit_temp > emerg_temp) {
 		dev_warn(dev, "%s : Critical threshold %d is above emergency threshold %d\n",
@@ -529,10 +531,14 @@ mlxsw_thermal_temp_and_thresholds_get(struct mlxsw_core *core, u8 slot_index,
 		 * it will cause driver probing failure.
 		 */
 		*p_temp = (int) temp;
+		*p_crit_temp = (int) crit_temp;
+		*p_emerg_temp = (int) emerg_temp;
 		return;
 	}
 	mlxsw_reg_mtmp_unpack(mtmp_pl, &temp, NULL, &crit_temp, &emerg_temp, NULL);
 	*p_temp = (int) temp;
+	*p_crit_temp = (int) crit_temp;
+	*p_emerg_temp = (int) emerg_temp;
 }
 
 static int mlxsw_thermal_module_temp_get(struct thermal_zone_device *tzdev,
@@ -541,7 +547,7 @@ static int mlxsw_thermal_module_temp_get(struct thermal_zone_device *tzdev,
 	struct mlxsw_thermal_module *tz = tzdev->devdata;
 	struct mlxsw_thermal *thermal = tz->parent;
 	struct device *dev = thermal->bus_info->dev;
-	int temp;
+	int temp, crit_temp, emerg_temp;
 	int err;
 
 	/* Do not read temperature in initialization stage. */
@@ -553,12 +559,13 @@ static int mlxsw_thermal_module_temp_get(struct thermal_zone_device *tzdev,
 	/* Read module temperature and thresholds. */
 	mlxsw_thermal_temp_and_thresholds_get(thermal->core, tz->slot_index,
 					      MLXSW_REG_MTMP_MODULE_INDEX_MIN + tz->module,
-					      &temp, NULL, NULL);
+					      &temp, &crit_temp, &emerg_temp);
 	if (!temp)
 		return 0;
 
 	/* Update trip points. */
-	err = mlxsw_thermal_module_trips_update(dev, thermal->core, tz);
+	err = mlxsw_thermal_module_trips_update(dev, thermal->core, tz, crit_temp,
+						emerg_temp);
 	if (!err && temp > 0)
 		mlxsw_thermal_tz_score_update(thermal, tzdev, tz->trips, temp);
 
-- 
2.20.1

