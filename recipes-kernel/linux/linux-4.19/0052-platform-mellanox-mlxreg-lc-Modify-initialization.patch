From 3d13d3f2183d32ddd69cf1fe52a696bb19fb905d Mon Sep 17 00:00:00 2001
From: Vadim Pasternak <vadimp@nvidia.com>
Date: Mon, 21 Sep 2020 08:17:19 +0300
Subject: [PATCH backport v4.19 4/4] platform: mellanox: mlxreg-lc: Modify
 initialization

Fixes during bring-up.

Signed-off-by: Vadim Pasternak <vadimp@nvidia.com>
---
 drivers/platform/mellanox/mlxreg-lc.c | 172 +++++++++++++++++++++-------------
 1 file changed, 105 insertions(+), 67 deletions(-)

diff --git a/drivers/platform/mellanox/mlxreg-lc.c b/drivers/platform/mellanox/mlxreg-lc.c
index 486f56e4b..1c6f50101 100644
--- a/drivers/platform/mellanox/mlxreg-lc.c
+++ b/drivers/platform/mellanox/mlxreg-lc.c
@@ -15,22 +15,23 @@
 
 /* I2C bus IO offsets */
 #define MLXREG_LC_REG_CPLD1_VER_OFFSET		0x2500
-#define MLXREG_LC_REG_CPLD2_VER_OFFSET		0x2501
+#define MLXREG_LC_REG_FPGA1_VER_OFFSET		0x2501
 #define MLXREG_LC_REG_CPLD1_PN_OFFSET		0x2504
-#define MLXREG_LC_REG_CPLD2_PN_OFFSET		0x2506
+#define MLXREG_LC_REG_FPGA1_PN_OFFSET		0x2506
 #define MLXREG_LC_REG_RESET_CAUSE_OFFSET	0x251d
 #define MLXREG_LC_REG_LED1_OFFSET		0x2520
 #define MLXREG_LC_REG_GP0_OFFSET		0x252e
 #define MLXREG_LC_REG_FIELD_UPGRADE		0x2534
 #define MLXREG_LC_CHANNEL_I2C_REG		0x25dc
 #define MLXREG_LC_REG_CPLD1_MVER_OFFSET		0x25de
-#define MLXREG_LC_REG_CPLD2_MVER_OFFSET		0x25df
+#define MLXREG_LC_REG_FPGA1_MVER_OFFSET		0x25df
 #define MLXREG_LC_REG_MAX_POWER_OFFSET		0x25f1
 #define MLXREG_LC_REG_CONFIG_OFFSET		0x25fb
 #define MLXREG_LC_REG_MAX			0x2600
 
 #define MLXREG_LC_BASE_NR		100
 #define MLXREG_LC_SET_BASE_NR(slot)	(MLXREG_LC_BASE_NR * (slot))
+#define MLXREG_LC_DEFER_TIME		(msecs_to_jiffies(10))
 
 /**
  * enum mlxreg_lc_type - line cards types
@@ -79,7 +80,9 @@ struct mlxreg_lc {
 	int topo_id;
 };
 
+//static INIT_LIST_HEAD(mlxreg_lc_list);
 static struct list_head mlxreg_lc_list = LIST_HEAD_INIT(mlxreg_lc_list);
+static DEFINE_MUTEX(mlxreg_lc_mutex);
 
 static bool mlxreg_lc_writeable_reg(struct device *dev, unsigned int reg)
 {
@@ -97,16 +100,16 @@ static bool mlxreg_lc_readable_reg(struct device *dev, unsigned int reg)
 {
 	switch (reg) {
 	case MLXREG_LC_REG_CPLD1_VER_OFFSET:
-	case MLXREG_LC_REG_CPLD2_VER_OFFSET:
+	case MLXREG_LC_REG_FPGA1_VER_OFFSET:
 	case MLXREG_LC_REG_CPLD1_PN_OFFSET:
-	case MLXREG_LC_REG_CPLD2_PN_OFFSET:
+	case MLXREG_LC_REG_FPGA1_PN_OFFSET:
 	case MLXREG_LC_REG_RESET_CAUSE_OFFSET:
 	case MLXREG_LC_REG_LED1_OFFSET:
 	case MLXREG_LC_REG_GP0_OFFSET:
 	case MLXREG_LC_REG_FIELD_UPGRADE:
 	case MLXREG_LC_CHANNEL_I2C_REG:
 	case MLXREG_LC_REG_CPLD1_MVER_OFFSET:
-	case MLXREG_LC_REG_CPLD2_MVER_OFFSET:
+	case MLXREG_LC_REG_FPGA1_MVER_OFFSET:
 	case MLXREG_LC_REG_MAX_POWER_OFFSET:
 	case MLXREG_LC_REG_CONFIG_OFFSET:
 		return true;
@@ -118,16 +121,16 @@ static bool mlxreg_lc_volatile_reg(struct device *dev, unsigned int reg)
 {
 	switch (reg) {
 	case MLXREG_LC_REG_CPLD1_VER_OFFSET:
-	case MLXREG_LC_REG_CPLD2_VER_OFFSET:
+	case MLXREG_LC_REG_FPGA1_VER_OFFSET:
 	case MLXREG_LC_REG_CPLD1_PN_OFFSET:
-	case MLXREG_LC_REG_CPLD2_PN_OFFSET:
+	case MLXREG_LC_REG_FPGA1_PN_OFFSET:
 	case MLXREG_LC_REG_RESET_CAUSE_OFFSET:
 	case MLXREG_LC_REG_LED1_OFFSET:
 	case MLXREG_LC_REG_GP0_OFFSET:
 	case MLXREG_LC_REG_FIELD_UPGRADE:
 	case MLXREG_LC_CHANNEL_I2C_REG:
 	case MLXREG_LC_REG_CPLD1_MVER_OFFSET:
-	case MLXREG_LC_REG_CPLD2_MVER_OFFSET:
+	case MLXREG_LC_REG_FPGA1_MVER_OFFSET:
 	case MLXREG_LC_REG_MAX_POWER_OFFSET:
 	case MLXREG_LC_REG_CONFIG_OFFSET:
 		return true;
@@ -263,8 +266,8 @@ static struct mlxreg_core_data mlxreg_lc_io_data[] = {
 		.mode = 0444,
 	},
 	{
-		.label = "cpld2_version",
-		.reg = MLXREG_LC_REG_CPLD2_VER_OFFSET,
+		.label = "fpga1_version",
+		.reg = MLXREG_LC_REG_FPGA1_VER_OFFSET,
 		.bit = GENMASK(7, 0),
 		.mode = 0444,
 	},
@@ -276,8 +279,8 @@ static struct mlxreg_core_data mlxreg_lc_io_data[] = {
 		.regnum = 2,
 	},
 	{
-		.label = "cpld2_pn",
-		.reg = MLXREG_LC_REG_CPLD2_PN_OFFSET,
+		.label = "fpga1_pn",
+		.reg = MLXREG_LC_REG_FPGA1_PN_OFFSET,
 		.bit = GENMASK(15, 0),
 		.mode = 0444,
 		.regnum = 2,
@@ -289,8 +292,8 @@ static struct mlxreg_core_data mlxreg_lc_io_data[] = {
 		.mode = 0444,
 	},
 	{
-		.label = "cpld2_version_min",
-		.reg = MLXREG_LC_REG_CPLD2_MVER_OFFSET,
+		.label = "fpga1_version_min",
+		.reg = MLXREG_LC_REG_FPGA1_MVER_OFFSET,
 		.bit = GENMASK(7, 0),
 		.mode = 0444,
 	},
@@ -459,32 +462,49 @@ mlxreg_lc_destroy_static_devices(struct mlxreg_lc *mlxreg_lc,
 	}
 }
 
-static int mlxreg_lc_ready_init(struct mlxplat_notifier_info *info)
+static int mlxreg_lc_power_on(struct mlxplat_notifier_info *info)
 {
-	struct mlxreg_lc *mlxreg_lc;
+	struct mlxreg_lc *mlxreg_lc, *lc;
+	int err;
+
+	mutex_lock(&mlxreg_lc_mutex);
 
-	list_for_each_entry(mlxreg_lc, &mlxreg_lc_list, list) {
+	list_for_each_entry_safe(mlxreg_lc, lc, &mlxreg_lc_list, list) {
 		/* Create static I2C device feeding by main power. */
-		if (mlxreg_lc->topo_id == info->topo_id)
-			return mlxreg_lc_create_static_devices(mlxreg_lc,
+		if (mlxreg_lc->topo_id == info->topo_id) {
+			err = mlxreg_lc_create_static_devices(mlxreg_lc,
 						mlxreg_lc->aux_devs,
 						mlxreg_lc->main_devs_num);
+
+			mutex_unlock(&mlxreg_lc_mutex);
+			return err;
+		}
 	}
 
+	mutex_unlock(&mlxreg_lc_mutex);
+
 	return -ENODEV;
 }
 
-static void mlxreg_lc_ready_exit(struct mlxplat_notifier_info *info)
+static void mlxreg_lc_power_off(struct mlxplat_notifier_info *info)
 {
-	struct mlxreg_lc *mlxreg_lc;
+	struct mlxreg_lc *mlxreg_lc, *lc;
 
-	list_for_each_entry(mlxreg_lc, &mlxreg_lc_list, list) {
+	mutex_lock(&mlxreg_lc_mutex);
+
+	list_for_each_entry_safe(mlxreg_lc, lc, &mlxreg_lc_list, list) {
 		/* Destroy static I2C device feeding by main power. */
-		if (mlxreg_lc->topo_id == info->topo_id)
-			return mlxreg_lc_destroy_static_devices(mlxreg_lc,
+		if (mlxreg_lc->topo_id == info->topo_id) {
+			mlxreg_lc_destroy_static_devices(mlxreg_lc,
 						mlxreg_lc->aux_devs,
 						mlxreg_lc->main_devs_num);
+
+			mutex_unlock(&mlxreg_lc_mutex);
+			return;
+		}
 	}
+
+	mutex_unlock(&mlxreg_lc_mutex);
 }
 
 /* Called under rcu_read_lock() */
@@ -492,20 +512,22 @@ static int
 mlxreg_lc_event(struct notifier_block *unused, unsigned long event, void *data)
 {
 	struct mlxplat_notifier_info *info = data;
-	int err = NOTIFY_DONE;
+	int err;
 
 	switch (event) {
-	case MLXREG_HOTPLUG_LC_READY:
-		if (info->action)
-			err = mlxreg_lc_ready_init(info);
-		else
-			mlxreg_lc_ready_exit(info);
-		break;
+	case MLXREG_HOTPLUG_LC_POWERED:
+		if (info->action) {
+			err = mlxreg_lc_power_on(info);
+			if (err)
+				return NOTIFY_BAD;
+		} else {
+			mlxreg_lc_power_off(info);
+		}
+		return NOTIFY_OK;
 	default:
 		break;
 	}
-
-	return err;
+	return NOTIFY_DONE;
 }
 
 /* Notifier block structure. */
@@ -647,14 +669,15 @@ static void mlxreg_lc_config_exit(struct mlxreg_lc *mlxreg_lc)
 	/* Unregister IO access driver. */
 	if (mlxreg_lc->io_regs)
 		platform_device_unregister(mlxreg_lc->io_regs);
-	/* Create mux infrastructure. */
+	/* Remove mux infrastructure. */
 	if (mlxreg_lc->mux)
 		platform_device_unregister(mlxreg_lc->mux);
 }
 
 static void
 mlxreg_lc_work(struct mlxreg_lc *mlxreg_lc, struct delayed_work *dwork,
-	       int defer_nr, struct mlxreg_hotplug_device *devs, int devs_num)
+	       int defer_nr, struct mlxreg_hotplug_device *devs, int devs_num,
+	       bool *finished)
 {
 	struct i2c_adapter *adap;
 
@@ -662,11 +685,13 @@ mlxreg_lc_work(struct mlxreg_lc *mlxreg_lc, struct delayed_work *dwork,
 	if (!adap) {
 		i2c_put_adapter(adap);
 		cancel_delayed_work(dwork);
-		schedule_delayed_work(dwork, msecs_to_jiffies(10));
+		schedule_delayed_work(dwork, MLXREG_LC_DEFER_TIME);
 		return;
 	}
 	i2c_put_adapter(adap);
 	cancel_delayed_work(dwork);
+	if (finished)
+		*finished = true;
 	mlxreg_lc_create_static_devices(mlxreg_lc, devs, devs_num);
 }
 
@@ -676,24 +701,35 @@ static void mlxreg_lc_work_main(struct work_struct *work)
 
 	mlxreg_lc = container_of(work, struct mlxreg_lc, dwork_main.work);
 	mlxreg_lc_work(mlxreg_lc, &mlxreg_lc->dwork_main, mlxreg_lc->defer_nr,
-		       mlxreg_lc->main_devs, mlxreg_lc->main_devs_num);
+		       mlxreg_lc->main_devs, mlxreg_lc->main_devs_num, NULL);
 }
 
 static void mlxreg_lc_work_aux(struct work_struct *work)
 {
 	struct mlxreg_lc *mlxreg_lc;
+	bool finished = false;
 
 	mlxreg_lc = container_of(work, struct mlxreg_lc, dwork_aux.work);
 	mlxreg_lc_work(mlxreg_lc, &mlxreg_lc->dwork_aux, mlxreg_lc->defer_nr,
-		       mlxreg_lc->aux_devs, mlxreg_lc->aux_devs_num);
+		       mlxreg_lc->aux_devs, mlxreg_lc->aux_devs_num, &finished);
+	if (!finished)
+		return;
+	/* Register notifier only when the first device is probed. */
+	mutex_lock(&mlxreg_lc_mutex);
+
+	if (list_empty(&mlxreg_lc_list))
+		mlxplat_blk_notifier_register(&mlxreg_lc_notifier_block);
+	list_add(&mlxreg_lc->list, &mlxreg_lc_list);
+
+	mutex_unlock(&mlxreg_lc_mutex);
 }
 
 static int mlxreg_lc_probe(struct platform_device *pdev)
 {
 	struct mlxreg_core_data *data;
 	struct mlxreg_lc *mlxreg_lc;
-	void *regmap;
-	int i, err;
+	void *regmap, *par_regmap;
+	int regval, i, err;
 
 	data = dev_get_platdata(&pdev->dev);
 	if (!data)
@@ -755,26 +791,30 @@ static int mlxreg_lc_probe(struct platform_device *pdev)
 	 */
 	mlxreg_lc->defer_nr = mlxreg_lc_chan[ARRAY_SIZE(mlxreg_lc_chan) - 1] +
 			      data->slot * 100;
+;
+	mlxreg_lc->topo_id = rol32(data->hpdev.nr, 16) |
+			     data->hpdev.brdinfo->addr;
+	platform_set_drvdata(pdev, mlxreg_lc);
+
 	/*
 	 * Initialize delayed work queues for handling attachment of line card
 	 * on-board devices. These devices can not be attached immediately, but
 	 * only when deferred adapter is getting available.
 	 */
 	INIT_DELAYED_WORK(&mlxreg_lc->dwork_aux, mlxreg_lc_work_aux);
-	INIT_DELAYED_WORK(&mlxreg_lc->dwork_main, mlxreg_lc_work_main);
-	schedule_delayed_work(&mlxreg_lc->dwork_aux, msecs_to_jiffies(10));
-	schedule_delayed_work(&mlxreg_lc->dwork_main, msecs_to_jiffies(10));
-	platform_set_drvdata(pdev, mlxreg_lc);
-	mlxreg_lc->topo_id = rol32(data->hpdev.nr, 16) |
-			     data->hpdev.brdinfo->addr;
+	schedule_delayed_work(&mlxreg_lc->dwork_aux, MLXREG_LC_DEFER_TIME);
 
-	/* Register notifier only when the first device is probed. */
-	if (list_empty(&mlxreg_lc_list)) {
-		err = mlxplat_blk_notifier_register(&mlxreg_lc_notifier_block);
-		if (!err)
-			goto mlxreg_lc_probe_fail;
+	par_regmap = data->hpdev.brdinfo->platform_data;
+	err = regmap_read(par_regmap, data->reg_prsnt, &regval);
+	if (err)
+		goto mlxreg_lc_probe_fail;
+
+	/* bring-up */ regval = ~regval;
+	if (regval & data->mask) {
+		INIT_DELAYED_WORK(&mlxreg_lc->dwork_main, mlxreg_lc_work_main);
+		schedule_delayed_work(&mlxreg_lc->dwork_main,
+				      MLXREG_LC_DEFER_TIME);
 	}
-	list_add(&mlxreg_lc->list, &mlxreg_lc_list);
 
 	return err;
 
@@ -785,29 +825,17 @@ mlxreg_lc_probe_fail:
 
 static int mlxreg_lc_remove(struct platform_device *pdev)
 {
+	struct mlxreg_core_data *data = dev_get_platdata(&pdev->dev);
 	struct mlxreg_lc *mlxreg_lc = platform_get_drvdata(pdev);
-	struct mlxreg_core_hotplug_platform_data *pdata;
-	struct mlxreg_core_data *data;
-
-	pdata = dev_get_platdata(&pdev->dev);
-	if (!pdata)
-		return -EINVAL;
-
-	if (!list_empty(&mlxreg_lc_list))
-		list_del_rcu(&mlxreg_lc->list);
-	/* Unregister notifier only when the last device is removed. */
-	if (list_empty(&mlxreg_lc_list))
-		mlxplat_blk_notifier_unregister(&mlxreg_lc_notifier_block);
 
 	/* Destroy static I2C device feeding by main power. */
-	mlxreg_lc_destroy_static_devices(mlxreg_lc, mlxreg_lc->aux_devs,
+	mlxreg_lc_destroy_static_devices(mlxreg_lc, mlxreg_lc->main_devs,
 					 mlxreg_lc->main_devs_num);
 	/* Destroy static I2C device feeding by auxiliary power. */
 	mlxreg_lc_destroy_static_devices(mlxreg_lc, mlxreg_lc->aux_devs,
 					 mlxreg_lc->aux_devs_num);
 	/* Unregister underlying drivers. */
 	mlxreg_lc_config_exit(mlxreg_lc);
-	data = pdata->items->data;
 	if (data->hpdev.client) {
 		i2c_unregister_device(data->hpdev.client);
 		data->hpdev.client = NULL;
@@ -815,6 +843,16 @@ static int mlxreg_lc_remove(struct platform_device *pdev)
 		data->hpdev.adapter = NULL;
 	}
 
+	mutex_lock(&mlxreg_lc_mutex);
+
+	if (!list_empty(&mlxreg_lc_list))
+		list_del_rcu(&mlxreg_lc->list);
+	/* Unregister notifier only when the last device is removed. */
+	if (list_empty(&mlxreg_lc_list))
+		mlxplat_blk_notifier_unregister(&mlxreg_lc_notifier_block);
+
+	mutex_unlock(&mlxreg_lc_mutex);
+
 	return 0;
 }
 
-- 
2.11.0

