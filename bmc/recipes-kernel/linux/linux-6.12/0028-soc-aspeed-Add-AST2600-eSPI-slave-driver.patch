From cf2478434350e372a5f2811f4ef2c0f6a4d356cd Mon Sep 17 00:00:00 2001
From: Vadim Pasternak <vadimp@nvidia.com>
Date: Sat, 17 Jan 2026 13:56:21 +0200
Subject: [PATCH] soc/aspeed: Add AST2600 eSPI slave driver

Add AST2600 eSPI slave driver from Aspeed SDK to enable full eSPI
functionality including peripheral channel (POST codes), OOB channel
(IPMI over eSPI), flash channel, and virtual wire support.

Files added:
- ast2600-espi.c : Main driver implementation (2000+ lines)
- ast2600-espi.h : Register definitions and hardware interface
- aspeed-espi-comm.h : Common structures and IOCTL definitions

The driver provides character device interfaces for each eSPI channel:
- /dev/aspeed-espi-peripheral : For POST code and memory cycle access
- /dev/aspeed-espi-vw : For virtual wire GPIO
- /dev/aspeed-espi-oob : For out-of-band communication (IPMI/KCS)
- /dev/aspeed-espi-flash : For flash channel access

Kconfig/Makefile updated to build driver when CONFIG_AST2600_ESPI=y.

This driver complements aspeed-lpc-snoop.c for POST code capture:
- SNOOP: Simple, mainline, works via LPC bridge
- eSPI: Full-featured, handles all eSPI channels properly

Source: Aspeed SDK linux tree
Compatible: "aspeed,ast2600-espi" (matches DTS configuration)

Upstream-Status: Pending
Signed-off-by: Vadim Pasternak <vadimp@nvidia.com>
---
 drivers/soc/aspeed/Kconfig            |    9 +
 drivers/soc/aspeed/Makefile           |    1 +
 drivers/soc/aspeed/aspeed-espi-comm.h |  206 +++
 drivers/soc/aspeed/ast2600-espi.c     | 2188 +++++++++++++++++++++++++
 drivers/soc/aspeed/ast2600-espi.h     |  297 ++++
 5 files changed, 2701 insertions(+)
 create mode 100644 drivers/soc/aspeed/aspeed-espi-comm.h
 create mode 100644 drivers/soc/aspeed/ast2600-espi.c
 create mode 100644 drivers/soc/aspeed/ast2600-espi.h

diff --git a/drivers/soc/aspeed/Kconfig b/drivers/soc/aspeed/Kconfig
index b4a537c9c09e..58bfcfc9cbcf 100644
--- a/drivers/soc/aspeed/Kconfig
+++ b/drivers/soc/aspeed/Kconfig
@@ -33,6 +33,15 @@ config ASPEED_LPC_PCC
 	  Enables the LPC PCC hardware on the ASPEED BMC, which
 	  is used to get the POST codes from the host CPU.
 
+config AST2600_ESPI
+	tristate "ASPEED AST2600 eSPI slave driver"
+	depends on ARCH_ASPEED || COMPILE_TEST
+	help
+	  Enable driver support for Aspeed AST2600 eSPI engine. The driver
+	  plays as a slave device in BMC to communicate with the Host over
+	  the eSPI interface. The four eSPI channels, namely peripheral,
+	  virtual wire, out-of-band, and flash are supported.
+
 config ASPEED_UART_ROUTING
 	tristate "ASPEED uart routing control"
 	select REGMAP
diff --git a/drivers/soc/aspeed/Makefile b/drivers/soc/aspeed/Makefile
index ea7073f51be6..78c6bd76ba04 100644
--- a/drivers/soc/aspeed/Makefile
+++ b/drivers/soc/aspeed/Makefile
@@ -8,5 +8,6 @@ obj-$(CONFIG_ASPEED_SBC)		+= aspeed-sbc.o
 obj-$(CONFIG_ASPEED_XDMA)		+= aspeed-xdma.o
 obj-$(CONFIG_ASPEED_MCTP)		+= aspeed-mctp.o
 obj-$(CONFIG_ASPEED_LPC_PCC)	+= aspeed-lpc-pcc.o
+obj-$(CONFIG_AST2600_ESPI)		+= ast2600-espi.o
 obj-$(CONFIG_ASPEED_OTP)        += aspeed-otp.o
 obj-y        += aspeed-2600-ara.o
diff --git a/drivers/soc/aspeed/aspeed-espi-comm.h b/drivers/soc/aspeed/aspeed-espi-comm.h
new file mode 100644
index 000000000000..29468437ad6f
--- /dev/null
+++ b/drivers/soc/aspeed/aspeed-espi-comm.h
@@ -0,0 +1,206 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2023 Aspeed Technology Inc.
+ */
+#ifndef __ASPEED_ESPI_COMM_H__
+#define __ASPEED_ESPI_COMM_H__
+
+#include <linux/ioctl.h>
+#include <linux/types.h>
+
+/*
+ * eSPI cycle type encoding
+ *
+ * Section 5.1 Cycle Types and Packet Format,
+ * Intel eSPI Interface Base Specification, Rev 1.0, Jan. 2016.
+ */
+#define ESPI_PERIF_MEMRD32		0x00
+#define ESPI_PERIF_MEMRD64		0x02
+#define ESPI_PERIF_MEMWR32		0x01
+#define ESPI_PERIF_MEMWR64		0x03
+#define ESPI_PERIF_MSG			0x10
+#define ESPI_PERIF_MSG_D		0x11
+#define ESPI_PERIF_SUC_CMPLT		0x06
+#define ESPI_PERIF_SUC_CMPLT_D_MIDDLE	0x09
+#define ESPI_PERIF_SUC_CMPLT_D_FIRST	0x0b
+#define ESPI_PERIF_SUC_CMPLT_D_LAST	0x0d
+#define ESPI_PERIF_SUC_CMPLT_D_ONLY	0x0f
+#define ESPI_PERIF_UNSUC_CMPLT		0x0c
+#define ESPI_OOB_MSG			0x21
+#define ESPI_FLASH_READ			0x00
+#define ESPI_FLASH_WRITE		0x01
+#define ESPI_FLASH_ERASE		0x02
+#define ESPI_FLASH_SUC_CMPLT		0x06
+#define ESPI_FLASH_SUC_CMPLT_D_MIDDLE	0x09
+#define ESPI_FLASH_SUC_CMPLT_D_FIRST	0x0b
+#define ESPI_FLASH_SUC_CMPLT_D_LAST	0x0d
+#define ESPI_FLASH_SUC_CMPLT_D_ONLY	0x0f
+#define ESPI_FLASH_UNSUC_CMPLT		0x0c
+
+/*
+ * eSPI packet format structure
+ *
+ * Section 5.1 Cycle Types and Packet Format,
+ * Intel eSPI Interface Base Specification, Rev 1.0, Jan. 2016.
+ */
+struct espi_comm_hdr {
+	uint8_t cyc;
+	uint8_t len_h : 4;
+	uint8_t tag : 4;
+	uint8_t len_l;
+};
+
+struct espi_perif_mem32 {
+	uint8_t cyc;
+	uint8_t len_h : 4;
+	uint8_t tag : 4;
+	uint8_t len_l;
+	uint32_t addr_be;
+	uint8_t data[];
+} __packed;
+
+struct espi_perif_mem64 {
+	uint8_t cyc;
+	uint8_t len_h : 4;
+	uint8_t tag : 4;
+	uint8_t len_l;
+	uint32_t addr_be;
+	uint8_t data[];
+} __packed;
+
+struct espi_perif_msg {
+	uint8_t cyc;
+	uint8_t len_h : 4;
+	uint8_t tag : 4;
+	uint8_t len_l;
+	uint8_t msg_code;
+	uint8_t msg_byte[4];
+	uint8_t data[];
+} __packed;
+
+struct espi_perif_cmplt {
+	uint8_t cyc;
+	uint8_t len_h : 4;
+	uint8_t tag : 4;
+	uint8_t len_l;
+	uint8_t data[];
+} __packed;
+
+struct espi_oob_msg {
+	uint8_t cyc;
+	uint8_t len_h : 4;
+	uint8_t tag : 4;
+	uint8_t len_l;
+	uint8_t data[];
+};
+
+struct espi_flash_rwe {
+	uint8_t cyc;
+	uint8_t len_h : 4;
+	uint8_t tag : 4;
+	uint8_t len_l;
+	uint32_t addr_be;
+	uint8_t data[];
+} __packed;
+
+struct espi_flash_cmplt {
+	uint8_t cyc;
+	uint8_t len_h : 4;
+	uint8_t tag : 4;
+	uint8_t len_l;
+	uint8_t data[];
+} __packed;
+
+#define ESPI_MAX_PLD_LEN	BIT(12)
+
+/*
+ * Aspeed IOCTL for eSPI raw packet send/receive
+ *
+ * This IOCTL interface works in the eSPI packet in/out paradigm.
+ *
+ * Only the virtual wire IOCTL is a special case which does not send
+ * or receive an eSPI packet. However, to keep a more consisten use from
+ * userspace, we make all of the four channel drivers serve through the
+ * IOCTL interface.
+ *
+ * For the eSPI packet format, refer to
+ *   Section 5.1 Cycle Types and Packet Format,
+ *   Intel eSPI Interface Base Specification, Rev 1.0, Jan. 2016.
+ *
+ * For the example user apps using these IOCTL, refer to
+ *   https://github.com/AspeedTech-BMC/aspeed_app/tree/master/espi_test
+ */
+#define __ASPEED_ESPI_IOCTL_MAGIC	0xb8
+
+/*
+ * we choose the longest header and the max payload size
+ * based on the Intel specification to define the maximum
+ * eSPI packet length
+ */
+#define ESPI_MAX_PKT_LEN	(sizeof(struct espi_perif_msg) + ESPI_MAX_PLD_LEN)
+
+struct aspeed_espi_ioc {
+	uint32_t pkt_len;
+	uint8_t *pkt;
+};
+
+/*
+ * Peripheral Channel (CH0)
+ *  - ASPEED_ESPI_PERIF_PC_GET_RX
+ *      Receive an eSPI Posted/Completion packet
+ *  - ASPEED_ESPI_PERIF_PC_PUT_TX
+ *      Transmit an eSPI Posted/Completion packet
+ *  - ASPEED_ESPI_PERIF_NP_PUT_TX
+ *      Transmit an eSPI Non-Posted packet
+ */
+#define ASPEED_ESPI_PERIF_PC_GET_RX	_IOR(__ASPEED_ESPI_IOCTL_MAGIC, \
+					     0x00, struct aspeed_espi_ioc)
+#define ASPEED_ESPI_PERIF_PC_PUT_TX	_IOW(__ASPEED_ESPI_IOCTL_MAGIC, \
+					     0x01, struct aspeed_espi_ioc)
+#define ASPEED_ESPI_PERIF_NP_PUT_TX	_IOW(__ASPEED_ESPI_IOCTL_MAGIC, \
+					     0x02, struct aspeed_espi_ioc)
+/*
+ * Virtual Wire Channel (CH1)
+ *  - ASPEED_ESPI_VW_GET_GPIO_VAL
+ *      Read the input value of GPIO over the VW channel
+ *  - ASPEED_ESPI_VW_PUT_GPIO_VAL
+ *      Write the output value of GPIO over the VW channel
+ *  - ASPEED_ESPI_VW_GET_GPIO_VAL1 (new feature in AST2700)
+ *      Read the input value1 of GPIO over the VW channel
+ *  - ASPEED_ESPI_VW_PUT_GPIO_VAL1 (new feature in AST2700)
+ *      Write the output value1 of GPIO over the VW channel
+ */
+#define ASPEED_ESPI_VW_GET_GPIO_VAL	_IOR(__ASPEED_ESPI_IOCTL_MAGIC, \
+					     0x10, uint32_t)
+#define ASPEED_ESPI_VW_PUT_GPIO_VAL	_IOW(__ASPEED_ESPI_IOCTL_MAGIC, \
+					     0x11, uint32_t)
+#ifdef CONFIG_ARM64
+#define ASPEED_ESPI_VW_GET_GPIO_VAL1	_IOR(__ASPEED_ESPI_IOCTL_MAGIC, \
+					     0x12, uint32_t)
+#define ASPEED_ESPI_VW_PUT_GPIO_VAL1	_IOW(__ASPEED_ESPI_IOCTL_MAGIC, \
+					     0x13, uint32_t)
+#endif
+/*
+ * Out-of-band Channel (CH2)
+ *  - ASPEED_ESPI_OOB_GET_RX
+ *      Receive an eSPI OOB packet
+ *  - ASPEED_ESPI_OOB_PUT_TX
+ *      Transmit an eSPI OOB packet
+ */
+#define ASPEED_ESPI_OOB_GET_RX		_IOR(__ASPEED_ESPI_IOCTL_MAGIC, \
+					     0x20, struct aspeed_espi_ioc)
+#define ASPEED_ESPI_OOB_PUT_TX		_IOW(__ASPEED_ESPI_IOCTL_MAGIC, \
+					     0x21, struct aspeed_espi_ioc)
+/*
+ * Flash Channel (CH3)
+ *  - ASPEED_ESPI_FLASH_GET_RX
+ *      Receive an eSPI flash packet
+ *  - ASPEED_ESPI_FLASH_PUT_TX
+ *      Transmit an eSPI flash packet
+ */
+#define ASPEED_ESPI_FLASH_GET_RX	_IOR(__ASPEED_ESPI_IOCTL_MAGIC, \
+					     0x30, struct aspeed_espi_ioc)
+#define ASPEED_ESPI_FLASH_PUT_TX	_IOW(__ASPEED_ESPI_IOCTL_MAGIC, \
+					     0x31, struct aspeed_espi_ioc)
+
+#endif
diff --git a/drivers/soc/aspeed/ast2600-espi.c b/drivers/soc/aspeed/ast2600-espi.c
new file mode 100644
index 000000000000..fd134afa9bfe
--- /dev/null
+++ b/drivers/soc/aspeed/ast2600-espi.c
@@ -0,0 +1,2188 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2023 Aspeed Technology Inc.
+ */
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/clk.h>
+#include <linux/sizes.h>
+#include <linux/module.h>
+#include <linux/bitfield.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/miscdevice.h>
+#include <linux/dma-mapping.h>
+#include <linux/uaccess.h>
+#include <linux/vmalloc.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/reset.h>
+
+#include "ast2600-espi.h"
+
+#define DEVICE_NAME		"aspeed-espi"
+
+#define PERIF_MCYC_ALIGN	SZ_64K
+#define PERIF_MMBI_ALIGN	SZ_64K
+#define PERIF_MMBI_INST_NUM	8
+
+#define OOB_DMA_RPTR_KEY	0x45538073
+#define OOB_DMA_DESC_NUM	8
+#define OOB_DMA_DESC_CUSTOM	0x4
+
+#define FLASH_SAFS_ALIGN	SZ_16M
+
+struct ast2600_espi_perif_mmbi {
+	void *b2h_virt;
+	void *h2b_virt;
+	dma_addr_t b2h_addr;
+	dma_addr_t h2b_addr;
+	struct miscdevice b2h_mdev;
+	struct miscdevice h2b_mdev;
+	bool host_rwp_update;
+	wait_queue_head_t wq;
+	struct ast2600_espi_perif *perif;
+};
+
+struct ast2600_espi_perif {
+	struct {
+		bool enable;
+		int irq;
+		void *virt;
+		dma_addr_t taddr;
+		uint32_t saddr;
+		uint32_t size;
+		uint32_t inst_size;
+		struct ast2600_espi_perif_mmbi inst[PERIF_MMBI_INST_NUM];
+	} mmbi;
+
+	struct {
+		bool enable;
+		void *virt;
+		dma_addr_t taddr;
+		uint32_t saddr;
+		uint32_t size;
+	} mcyc;
+
+	struct {
+		bool enable;
+		void *np_tx_virt;
+		dma_addr_t np_tx_addr;
+		void *pc_tx_virt;
+		dma_addr_t pc_tx_addr;
+		void *pc_rx_virt;
+		dma_addr_t pc_rx_addr;
+	} dma;
+
+	bool rx_ready;
+	wait_queue_head_t wq;
+
+	spinlock_t lock;
+	struct mutex np_tx_mtx;
+	struct mutex pc_tx_mtx;
+	struct mutex pc_rx_mtx;
+
+	struct miscdevice mdev;
+};
+
+struct ast2600_espi_vw {
+	struct {
+		bool hw_mode;
+		uint32_t dir;
+		uint32_t val;
+	} gpio;
+
+	struct miscdevice mdev;
+};
+
+struct ast2600_espi_oob_dma_tx_desc {
+	uint32_t data_addr;
+	uint8_t cyc;
+	uint16_t tag : 4;
+	uint16_t len : 12;
+	uint8_t msg_type : 3;
+	uint8_t raz0 : 1;
+	uint8_t pec : 1;
+	uint8_t int_en : 1;
+	uint8_t pause : 1;
+	uint8_t raz1 : 1;
+	uint32_t raz2;
+	uint32_t raz3;
+} __packed;
+
+struct ast2600_espi_oob_dma_rx_desc {
+	uint32_t data_addr;
+	uint8_t cyc;
+	uint16_t tag : 4;
+	uint16_t len : 12;
+	uint8_t raz : 7;
+	uint8_t dirty : 1;
+} __packed;
+
+struct ast2600_espi_oob {
+	struct {
+		bool enable;
+		struct ast2600_espi_oob_dma_tx_desc *txd_virt;
+		dma_addr_t txd_addr;
+		struct ast2600_espi_oob_dma_rx_desc *rxd_virt;
+		dma_addr_t rxd_addr;
+		void *tx_virt;
+		dma_addr_t tx_addr;
+		void *rx_virt;
+		dma_addr_t rx_addr;
+	} dma;
+
+	bool rx_ready;
+	wait_queue_head_t wq;
+
+	spinlock_t lock;
+	struct mutex tx_mtx;
+	struct mutex rx_mtx;
+
+	struct miscdevice mdev;
+};
+
+struct ast2600_espi_flash {
+	struct {
+		uint32_t mode;
+		phys_addr_t taddr;
+		uint32_t size;
+	} safs;
+
+	struct {
+		bool enable;
+		void *tx_virt;
+		dma_addr_t tx_addr;
+		void *rx_virt;
+		dma_addr_t rx_addr;
+	} dma;
+
+	bool rx_ready;
+	wait_queue_head_t wq;
+
+	spinlock_t lock;
+	struct mutex rx_mtx;
+	struct mutex tx_mtx;
+
+	struct miscdevice mdev;
+};
+
+struct ast2600_espi {
+	struct device *dev;
+	void __iomem *regs;
+	struct reset_control *rst;
+	struct clk *clk;
+	int irq;
+
+	struct ast2600_espi_perif perif;
+	struct ast2600_espi_vw vw;
+	struct ast2600_espi_oob oob;
+	struct ast2600_espi_flash flash;
+};
+
+/* peripheral channel (CH0) */
+static int ast2600_espi_mmbi_b2h_mmap(struct file *fp, struct vm_area_struct *vma)
+{
+	struct ast2600_espi_perif_mmbi *mmbi;
+	struct ast2600_espi_perif *perif;
+	struct ast2600_espi *espi;
+	unsigned long vm_size;
+	pgprot_t prot;
+
+	mmbi = container_of(fp->private_data, struct ast2600_espi_perif_mmbi, b2h_mdev);
+
+	perif = mmbi->perif;
+
+	espi = container_of(perif, struct ast2600_espi, perif);
+
+	vm_size = vma->vm_end - vma->vm_start;
+	prot = vma->vm_page_prot;
+
+	if (((vma->vm_pgoff << PAGE_SHIFT) + vm_size) > (SZ_4K << perif->mmbi.inst_size))
+		return -EINVAL;
+
+	prot = pgprot_noncached(prot);
+
+	if (remap_pfn_range(vma, vma->vm_start,
+			    (mmbi->b2h_addr >> PAGE_SHIFT) + vma->vm_pgoff,
+			    vm_size, prot))
+		return -EAGAIN;
+
+	return 0;
+}
+
+static int ast2600_espi_mmbi_h2b_mmap(struct file *fp, struct vm_area_struct *vma)
+{
+	struct ast2600_espi_perif_mmbi *mmbi;
+	struct ast2600_espi_perif *perif;
+	struct ast2600_espi *espi;
+	unsigned long vm_size;
+	pgprot_t prot;
+
+	mmbi = container_of(fp->private_data, struct ast2600_espi_perif_mmbi, h2b_mdev);
+
+	perif = mmbi->perif;
+
+	espi = container_of(perif, struct ast2600_espi, perif);
+
+	vm_size = vma->vm_end - vma->vm_start;
+	prot = vma->vm_page_prot;
+
+	if (((vma->vm_pgoff << PAGE_SHIFT) + vm_size) > (SZ_4K << perif->mmbi.inst_size))
+		return -EINVAL;
+
+	prot = pgprot_noncached(prot);
+
+	if (remap_pfn_range(vma, vma->vm_start,
+			    (mmbi->h2b_addr >> PAGE_SHIFT) + vma->vm_pgoff,
+			    vm_size, prot))
+		return -EAGAIN;
+
+	return 0;
+}
+
+static __poll_t ast2600_espi_mmbi_h2b_poll(struct file *fp, struct poll_table_struct *pt)
+{
+	struct ast2600_espi_perif_mmbi *mmbi;
+
+	mmbi = container_of(fp->private_data, struct ast2600_espi_perif_mmbi, h2b_mdev);
+
+	poll_wait(fp, &mmbi->wq, pt);
+
+	if (!mmbi->host_rwp_update)
+		return 0;
+
+	mmbi->host_rwp_update = false;
+
+	return EPOLLIN;
+}
+
+static long ast2600_espi_perif_pc_get_rx(struct file *fp,
+					 struct ast2600_espi_perif *perif,
+					 struct aspeed_espi_ioc *ioc)
+{
+	uint32_t reg, cyc, tag, len;
+	struct ast2600_espi *espi;
+	struct espi_comm_hdr *hdr;
+	unsigned long flags;
+	uint32_t pkt_len;
+	uint8_t *pkt;
+	int i, rc;
+
+	espi = container_of(perif, struct ast2600_espi, perif);
+
+	if (fp->f_flags & O_NONBLOCK) {
+		if (!mutex_trylock(&perif->pc_rx_mtx))
+			return -EAGAIN;
+
+		if (!perif->rx_ready) {
+			rc = -ENODATA;
+			goto unlock_mtx_n_out;
+		}
+	} else {
+		mutex_lock(&perif->pc_rx_mtx);
+
+		if (!perif->rx_ready) {
+			rc = wait_event_interruptible(perif->wq, perif->rx_ready);
+			if (rc == -ERESTARTSYS) {
+				rc = -EINTR;
+				goto unlock_mtx_n_out;
+			}
+		}
+	}
+
+	/*
+	 * common header (i.e. cycle type, tag, and length)
+	 * part is written to HW registers
+	 */
+	reg = readl(espi->regs + ESPI_PERIF_PC_RX_CTRL);
+	cyc = FIELD_GET(ESPI_PERIF_PC_RX_CTRL_CYC, reg);
+	tag = FIELD_GET(ESPI_PERIF_PC_RX_CTRL_TAG, reg);
+	len = FIELD_GET(ESPI_PERIF_PC_RX_CTRL_LEN, reg);
+
+	/*
+	 * calculate the length of the rest part of the
+	 * eSPI packet to be read from HW and copied to
+	 * user space.
+	 */
+	switch (cyc) {
+	case ESPI_PERIF_MSG:
+		pkt_len = sizeof(struct espi_perif_msg);
+		break;
+	case ESPI_PERIF_MSG_D:
+		pkt_len = ((len) ? len : ESPI_MAX_PLD_LEN) +
+			  sizeof(struct espi_perif_msg);
+		break;
+	case ESPI_PERIF_SUC_CMPLT_D_MIDDLE:
+	case ESPI_PERIF_SUC_CMPLT_D_FIRST:
+	case ESPI_PERIF_SUC_CMPLT_D_LAST:
+	case ESPI_PERIF_SUC_CMPLT_D_ONLY:
+		pkt_len = ((len) ? len : ESPI_MAX_PLD_LEN) +
+			  sizeof(struct espi_perif_cmplt);
+		break;
+	case ESPI_PERIF_SUC_CMPLT:
+	case ESPI_PERIF_UNSUC_CMPLT:
+		pkt_len = sizeof(struct espi_perif_cmplt);
+		break;
+	default:
+		rc = -EFAULT;
+		goto unlock_mtx_n_out;
+	}
+
+	if (ioc->pkt_len < pkt_len) {
+		rc = -EINVAL;
+		goto unlock_mtx_n_out;
+	}
+
+	pkt = vmalloc(pkt_len);
+	if (!pkt) {
+		rc = -ENOMEM;
+		goto unlock_mtx_n_out;
+	}
+
+	hdr = (struct espi_comm_hdr *)pkt;
+	hdr->cyc = cyc;
+	hdr->tag = tag;
+	hdr->len_h = len >> 8;
+	hdr->len_l = len & 0xff;
+
+	if (perif->dma.enable) {
+		memcpy(hdr + 1, perif->dma.pc_rx_virt, pkt_len - sizeof(*hdr));
+	} else {
+		for (i = sizeof(*hdr); i < pkt_len; ++i)
+			reg = readl(espi->regs + ESPI_PERIF_PC_RX_DATA) & 0xff;
+	}
+
+	if (copy_to_user((void __user *)ioc->pkt, pkt, pkt_len)) {
+		rc = -EFAULT;
+		goto free_n_out;
+	}
+
+	spin_lock_irqsave(&perif->lock, flags);
+
+	writel(ESPI_PERIF_PC_RX_CTRL_SERV_PEND, espi->regs + ESPI_PERIF_PC_RX_CTRL);
+	perif->rx_ready = 0;
+
+	spin_unlock_irqrestore(&perif->lock, flags);
+
+	rc = 0;
+
+free_n_out:
+	vfree(pkt);
+
+unlock_mtx_n_out:
+	mutex_unlock(&perif->pc_rx_mtx);
+
+	return rc;
+}
+
+static long ast2600_espi_perif_pc_put_tx(struct file *fp,
+					 struct ast2600_espi_perif *perif,
+					 struct aspeed_espi_ioc *ioc)
+{
+	uint32_t reg, cyc, tag, len;
+	struct ast2600_espi *espi;
+	struct espi_comm_hdr *hdr;
+	uint8_t *pkt;
+	int i, rc;
+
+	espi = container_of(perif, struct ast2600_espi, perif);
+
+	if (!mutex_trylock(&perif->pc_tx_mtx))
+		return -EAGAIN;
+
+	reg = readl(espi->regs + ESPI_PERIF_PC_TX_CTRL);
+	if (reg & ESPI_PERIF_PC_TX_CTRL_TRIG_PEND) {
+		rc = -EBUSY;
+		goto unlock_n_out;
+	}
+
+	pkt = vmalloc(ioc->pkt_len);
+	if (!pkt) {
+		rc = -ENOMEM;
+		goto unlock_n_out;
+	}
+
+	hdr = (struct espi_comm_hdr *)pkt;
+
+	if (copy_from_user(pkt, (void __user *)ioc->pkt, ioc->pkt_len)) {
+		rc = -EFAULT;
+		goto free_n_out;
+	}
+
+	/*
+	 * common header (i.e. cycle type, tag, and length)
+	 * part is written to HW registers
+	 */
+	if (perif->dma.enable) {
+		memcpy(perif->dma.pc_tx_virt, hdr + 1, ioc->pkt_len - sizeof(*hdr));
+		dma_wmb();
+	} else {
+		for (i = sizeof(*hdr); i < ioc->pkt_len; ++i)
+			writel(pkt[i], espi->regs + ESPI_PERIF_PC_TX_DATA);
+	}
+
+	cyc = hdr->cyc;
+	tag = hdr->tag;
+	len = (hdr->len_h << 8) | (hdr->len_l & 0xff);
+
+	reg = FIELD_PREP(ESPI_PERIF_PC_TX_CTRL_CYC, cyc)
+	      | FIELD_PREP(ESPI_PERIF_PC_TX_CTRL_TAG, tag)
+	      | FIELD_PREP(ESPI_PERIF_PC_TX_CTRL_LEN, len)
+	      | ESPI_PERIF_PC_TX_CTRL_TRIG_PEND;
+	writel(reg, espi->regs + ESPI_PERIF_PC_TX_CTRL);
+
+	rc = 0;
+
+free_n_out:
+	vfree(pkt);
+
+unlock_n_out:
+	mutex_unlock(&perif->pc_tx_mtx);
+
+	return rc;
+}
+
+static long ast2600_espi_perif_np_put_tx(struct file *fp,
+					 struct ast2600_espi_perif *perif,
+					 struct aspeed_espi_ioc *ioc)
+{
+	uint32_t reg, cyc, tag, len;
+	struct ast2600_espi *espi;
+	struct espi_comm_hdr *hdr;
+	uint8_t *pkt;
+	int i, rc;
+
+	espi = container_of(perif, struct ast2600_espi, perif);
+
+	if (!mutex_trylock(&perif->np_tx_mtx))
+		return -EAGAIN;
+
+	reg = readl(espi->regs + ESPI_PERIF_NP_TX_CTRL);
+	if (reg & ESPI_PERIF_NP_TX_CTRL_TRIG_PEND) {
+		rc = -EBUSY;
+		goto unlock_n_out;
+	}
+
+	pkt = vmalloc(ioc->pkt_len);
+	if (!pkt) {
+		rc = -ENOMEM;
+		goto unlock_n_out;
+	}
+
+	hdr = (struct espi_comm_hdr *)pkt;
+
+	if (copy_from_user(pkt, (void __user *)ioc->pkt, ioc->pkt_len)) {
+		rc = -EFAULT;
+		goto free_n_out;
+	}
+
+	/*
+	 * common header (i.e. cycle type, tag, and length)
+	 * part is written to HW registers
+	 */
+	if (perif->dma.enable) {
+		memcpy(perif->dma.np_tx_virt, hdr + 1, ioc->pkt_len - sizeof(*hdr));
+		dma_wmb();
+	} else {
+		for (i = sizeof(*hdr); i < ioc->pkt_len; ++i)
+			writel(pkt[i], espi->regs + ESPI_PERIF_NP_TX_DATA);
+	}
+
+	cyc = hdr->cyc;
+	tag = hdr->tag;
+	len = (hdr->len_h << 8) | (hdr->len_l & 0xff);
+
+	reg = FIELD_PREP(ESPI_PERIF_NP_TX_CTRL_CYC, cyc)
+	      | FIELD_PREP(ESPI_PERIF_NP_TX_CTRL_TAG, tag)
+	      | FIELD_PREP(ESPI_PERIF_NP_TX_CTRL_LEN, len)
+	      | ESPI_PERIF_NP_TX_CTRL_TRIG_PEND;
+	writel(reg, espi->regs + ESPI_PERIF_NP_TX_CTRL);
+
+	rc = 0;
+
+free_n_out:
+	vfree(pkt);
+
+unlock_n_out:
+	mutex_unlock(&perif->np_tx_mtx);
+
+	return rc;
+}
+
+static long ast2600_espi_perif_ioctl(struct file *fp, unsigned int cmd, unsigned long arg)
+{
+	struct ast2600_espi_perif *perif;
+	struct aspeed_espi_ioc ioc;
+
+	perif = container_of(fp->private_data, struct ast2600_espi_perif, mdev);
+
+	if (copy_from_user(&ioc, (void __user *)arg, sizeof(ioc)))
+		return -EFAULT;
+
+	if (ioc.pkt_len > ESPI_MAX_PKT_LEN)
+		return -EINVAL;
+
+	switch (cmd) {
+	case ASPEED_ESPI_PERIF_PC_GET_RX:
+		return ast2600_espi_perif_pc_get_rx(fp, perif, &ioc);
+	case ASPEED_ESPI_PERIF_PC_PUT_TX:
+		return ast2600_espi_perif_pc_put_tx(fp, perif, &ioc);
+	case ASPEED_ESPI_PERIF_NP_PUT_TX:
+		return ast2600_espi_perif_np_put_tx(fp, perif, &ioc);
+	default:
+		break;
+	};
+
+	return -EINVAL;
+}
+
+static int ast2600_espi_perif_mmap(struct file *fp, struct vm_area_struct *vma)
+{
+	struct ast2600_espi_perif *perif;
+	unsigned long vm_size;
+	pgprot_t vm_prot;
+
+	perif = container_of(fp->private_data, struct ast2600_espi_perif, mdev);
+	if (!perif->mcyc.enable)
+		return -EPERM;
+
+	vm_size = vma->vm_end - vma->vm_start;
+	vm_prot = vma->vm_page_prot;
+
+	if (((vma->vm_pgoff << PAGE_SHIFT) + vm_size) > perif->mcyc.size)
+		return -EINVAL;
+
+	vm_prot = pgprot_noncached(vm_prot);
+
+	if (remap_pfn_range(vma, vma->vm_start,
+			    (perif->mcyc.taddr >> PAGE_SHIFT) + vma->vm_pgoff,
+			    vm_size, vm_prot))
+		return -EAGAIN;
+
+	return 0;
+}
+
+static const struct file_operations ast2600_espi_mmbi_b2h_fops = {
+	.owner = THIS_MODULE,
+	.mmap = ast2600_espi_mmbi_b2h_mmap,
+};
+
+static const struct file_operations ast2600_espi_mmbi_h2b_fops = {
+	.owner = THIS_MODULE,
+	.mmap = ast2600_espi_mmbi_h2b_mmap,
+	.poll = ast2600_espi_mmbi_h2b_poll,
+};
+
+static const struct file_operations ast2600_espi_perif_fops = {
+	.owner = THIS_MODULE,
+	.mmap = ast2600_espi_perif_mmap,
+	.unlocked_ioctl = ast2600_espi_perif_ioctl,
+};
+
+static irqreturn_t ast2600_espi_perif_mmbi_isr(int irq, void *arg)
+{
+	struct ast2600_espi_perif_mmbi *mmbi;
+	struct ast2600_espi_perif *perif;
+	struct ast2600_espi *espi;
+	uint32_t sts, tmp;
+	uint32_t *p;
+	int i;
+
+	espi = (struct ast2600_espi *)arg;
+
+	perif = &espi->perif;
+
+	sts = readl(espi->regs + ESPI_MMBI_INT_STS);
+	if (!sts)
+		return IRQ_NONE;
+
+	for (i = 0, tmp = sts; i < PERIF_MMBI_INST_NUM; ++i, tmp >>= 2) {
+		if (!(tmp & 0x3))
+			continue;
+
+		mmbi = &perif->mmbi.inst[i];
+
+		p = (uint32_t *)mmbi->h2b_virt;
+		p[0] = readl(espi->regs + ESPI_MMBI_HOST_RWP(i));
+		p[1] = readl(espi->regs + ESPI_MMBI_HOST_RWP(i) + 4);
+
+		mmbi->host_rwp_update = true;
+
+		wake_up_interruptible(&mmbi->wq);
+	}
+
+	writel(sts, espi->regs + ESPI_MMBI_INT_STS);
+
+	return IRQ_HANDLED;
+}
+
+static void ast2600_espi_perif_isr(struct ast2600_espi *espi)
+{
+	struct ast2600_espi_perif *perif;
+	unsigned long flags;
+	uint32_t sts;
+
+	perif = &espi->perif;
+
+	sts = readl(espi->regs + ESPI_INT_STS);
+
+	if (sts & ESPI_INT_STS_PERIF_PC_RX_CMPLT) {
+		writel(ESPI_INT_STS_PERIF_PC_RX_CMPLT, espi->regs + ESPI_INT_STS);
+
+		spin_lock_irqsave(&perif->lock, flags);
+		perif->rx_ready = true;
+		spin_unlock_irqrestore(&perif->lock, flags);
+
+		wake_up_interruptible(&perif->wq);
+	}
+}
+
+static void ast2600_espi_perif_sw_reset(struct ast2600_espi *espi)
+{
+	struct device *dev;
+	uint32_t reg;
+
+	dev = espi->dev;
+
+	reg = readl(espi->regs + ESPI_CTRL);
+	reg &= ~(ESPI_CTRL_PERIF_NP_TX_SW_RST
+		 | ESPI_CTRL_PERIF_NP_RX_SW_RST
+		 | ESPI_CTRL_PERIF_PC_TX_SW_RST
+		 | ESPI_CTRL_PERIF_PC_RX_SW_RST
+		 | ESPI_CTRL_PERIF_NP_TX_DMA_EN
+		 | ESPI_CTRL_PERIF_PC_TX_DMA_EN
+		 | ESPI_CTRL_PERIF_PC_RX_DMA_EN
+		 | ESPI_CTRL_PERIF_SW_RDY);
+	writel(reg, espi->regs + ESPI_CTRL);
+
+	udelay(1);
+
+	reg |= (ESPI_CTRL_PERIF_NP_TX_SW_RST
+		| ESPI_CTRL_PERIF_NP_RX_SW_RST
+		| ESPI_CTRL_PERIF_PC_TX_SW_RST
+		| ESPI_CTRL_PERIF_PC_RX_SW_RST);
+	writel(reg, espi->regs + ESPI_CTRL);
+}
+
+static void ast2600_espi_perif_reset(struct ast2600_espi *espi)
+{
+	struct ast2600_espi_perif *perif;
+	struct device *dev;
+	uint32_t reg, mask;
+
+	dev = espi->dev;
+
+	perif = &espi->perif;
+
+	writel(ESPI_INT_EN_PERIF, espi->regs + ESPI_INT_EN_CLR);
+	writel(ESPI_INT_STS_PERIF, espi->regs + ESPI_INT_STS);
+
+	writel(0x0, espi->regs + ESPI_MMBI_INT_EN);
+	writel(0xffffffff, espi->regs + ESPI_MMBI_INT_STS);
+
+	reg = readl(espi->regs + ESPI_CTRL2);
+	reg &= ~(ESPI_CTRL2_MCYC_RD_DIS_WDT | ESPI_CTRL2_MCYC_WR_DIS_WDT);
+	writel(reg, espi->regs + ESPI_CTRL2);
+
+	reg = readl(espi->regs + ESPI_CTRL);
+	reg &= ~(ESPI_CTRL_PERIF_NP_TX_DMA_EN
+		 | ESPI_CTRL_PERIF_PC_TX_DMA_EN
+		 | ESPI_CTRL_PERIF_PC_RX_DMA_EN
+		 | ESPI_CTRL_PERIF_SW_RDY);
+	writel(reg, espi->regs + ESPI_CTRL);
+
+	if (perif->mmbi.enable) {
+		reg = readl(espi->regs + ESPI_MMBI_CTRL);
+		reg &= ~(ESPI_MMBI_CTRL_EN);
+		writel(reg, espi->regs + ESPI_MMBI_CTRL);
+
+		mask = ~(perif->mmbi.size - 1);
+		writel(mask, espi->regs + ESPI_PERIF_MMBI_MASK);
+		writel(perif->mmbi.saddr, espi->regs + ESPI_PERIF_MMBI_SADDR);
+		writel(perif->mmbi.taddr, espi->regs + ESPI_PERIF_MMBI_TADDR);
+
+		writel(0xffffffff, espi->regs + ESPI_MMBI_INT_EN);
+
+		reg = FIELD_PREP(ESPI_MMBI_CTRL_INST_SZ, perif->mmbi.inst_size)
+			| FIELD_PREP(ESPI_MMBI_CTRL_TOTAL_SZ, perif->mmbi.inst_size)
+			| ESPI_MMBI_CTRL_EN;
+		writel(reg, espi->regs + ESPI_MMBI_CTRL);
+
+		reg = readl(espi->regs + ESPI_CTRL2) & ~(ESPI_CTRL2_MMBI_RD_DIS | ESPI_CTRL2_MMBI_WR_DIS);
+		writel(reg, espi->regs + ESPI_CTRL2);
+	}
+
+	if (perif->mcyc.enable) {
+		mask = ~(perif->mcyc.size - 1);
+		writel(mask, espi->regs + ESPI_PERIF_MCYC_MASK);
+		writel(perif->mcyc.saddr, espi->regs + ESPI_PERIF_MCYC_SADDR);
+		writel(perif->mcyc.taddr, espi->regs + ESPI_PERIF_MCYC_TADDR);
+
+		reg = readl(espi->regs + ESPI_CTRL2) & ~(ESPI_CTRL2_MCYC_RD_DIS | ESPI_CTRL2_MCYC_WR_DIS);
+		writel(reg, espi->regs + ESPI_CTRL2);
+	}
+
+	if (perif->dma.enable) {
+		writel(perif->dma.np_tx_addr, espi->regs + ESPI_PERIF_NP_TX_DMA);
+		writel(perif->dma.pc_tx_addr, espi->regs + ESPI_PERIF_PC_TX_DMA);
+		writel(perif->dma.pc_rx_addr, espi->regs + ESPI_PERIF_PC_RX_DMA);
+
+		reg = readl(espi->regs + ESPI_CTRL)
+		      | ESPI_CTRL_PERIF_NP_TX_DMA_EN
+		      | ESPI_CTRL_PERIF_PC_TX_DMA_EN
+		      | ESPI_CTRL_PERIF_PC_RX_DMA_EN;
+		writel(reg, espi->regs + ESPI_CTRL);
+	}
+
+	writel(ESPI_INT_EN_PERIF_PC_RX_CMPLT, espi->regs + ESPI_INT_EN);
+
+	reg = readl(espi->regs + ESPI_CTRL) | ESPI_CTRL_PERIF_SW_RDY;
+	writel(reg, espi->regs + ESPI_CTRL);
+}
+
+static int ast2600_espi_perif_probe(struct ast2600_espi *espi)
+{
+	struct ast2600_espi_perif_mmbi *mmbi;
+	struct ast2600_espi_perif *perif;
+	struct platform_device *pdev;
+	struct device *dev;
+	int i, rc;
+
+	dev = espi->dev;
+
+	perif = &espi->perif;
+
+	init_waitqueue_head(&perif->wq);
+
+	spin_lock_init(&perif->lock);
+
+	mutex_init(&perif->np_tx_mtx);
+	mutex_init(&perif->pc_tx_mtx);
+	mutex_init(&perif->pc_rx_mtx);
+
+	perif->mmbi.enable = of_property_read_bool(dev->of_node, "perif-mmbi-enable");
+	if (perif->mmbi.enable) {
+		pdev = container_of(dev, struct platform_device, dev);
+
+		perif->mmbi.irq = platform_get_irq(pdev, 1);
+		if (perif->mmbi.irq < 0) {
+			dev_err(dev, "cannot get MMBI IRQ number\n");
+			return -ENODEV;
+		}
+
+		rc = of_property_read_u32(dev->of_node, "perif-mmbi-src-addr", &perif->mmbi.saddr);
+		if (rc || !IS_ALIGNED(perif->mmbi.saddr, PERIF_MMBI_ALIGN)) {
+			dev_err(dev, "cannot get 64KB-aligned MMBI host address\n");
+			return -ENODEV;
+		}
+
+		rc = of_property_read_u32(dev->of_node, "perif-mmbi-instance-size", &perif->mmbi.inst_size);
+		if (rc || perif->mmbi.inst_size >= MMBI_INST_SIZE_TYPES) {
+			dev_err(dev, "cannot get valid MMBI instance size\n");
+			return -EINVAL;
+		}
+
+		perif->mmbi.size = (SZ_8K << perif->mmbi.inst_size) * PERIF_MMBI_INST_NUM;
+		perif->mmbi.virt = dmam_alloc_coherent(dev, perif->mmbi.size,
+						       &perif->mmbi.taddr, GFP_KERNEL);
+		if (!perif->mmbi.virt) {
+			dev_err(dev, "cannot allocate MMBI\n");
+			return -ENOMEM;
+		}
+
+		for (i = 0; i < PERIF_MMBI_INST_NUM; ++i) {
+			mmbi = &perif->mmbi.inst[i];
+
+			init_waitqueue_head(&mmbi->wq);
+
+			mmbi->perif = perif;
+			mmbi->host_rwp_update = false;
+
+			mmbi->b2h_virt = perif->mmbi.virt + ((SZ_4K << perif->mmbi.inst_size) * i);
+			mmbi->b2h_addr = perif->mmbi.taddr + ((SZ_4K << perif->mmbi.inst_size) * i);
+			mmbi->b2h_mdev.parent = dev;
+			mmbi->b2h_mdev.minor = MISC_DYNAMIC_MINOR;
+			mmbi->b2h_mdev.name = devm_kasprintf(dev, GFP_KERNEL, "%s-mmbi-b2h%d", DEVICE_NAME, i);
+			mmbi->b2h_mdev.fops = &ast2600_espi_mmbi_b2h_fops;
+			rc = misc_register(&mmbi->b2h_mdev);
+			if (rc) {
+				dev_err(dev, "cannot register device %s\n", mmbi->b2h_mdev.name);
+				return rc;
+			}
+
+			mmbi->h2b_virt = perif->mmbi.virt + ((SZ_4K << perif->mmbi.inst_size) * (i + PERIF_MMBI_INST_NUM));
+			mmbi->h2b_addr = perif->mmbi.taddr + ((SZ_4K << perif->mmbi.inst_size) * (i + PERIF_MMBI_INST_NUM));
+			mmbi->h2b_mdev.parent = dev;
+			mmbi->h2b_mdev.minor = MISC_DYNAMIC_MINOR;
+			mmbi->h2b_mdev.name = devm_kasprintf(dev, GFP_KERNEL, "%s-mmbi-h2b%d", DEVICE_NAME, i);
+			mmbi->h2b_mdev.fops = &ast2600_espi_mmbi_h2b_fops;
+			rc = misc_register(&mmbi->h2b_mdev);
+			if (rc) {
+				dev_err(dev, "cannot register device %s\n", mmbi->h2b_mdev.name);
+				return rc;
+			}
+		}
+	}
+
+	perif->mcyc.enable = of_property_read_bool(dev->of_node, "perif-mcyc-enable");
+	if (perif->mcyc.enable) {
+		if (perif->mmbi.enable) {
+			dev_err(dev, "cannot enable memory cycle, occupied by MMBI\n");
+			return -EPERM;
+		}
+
+		rc = of_property_read_u32(dev->of_node, "perif-mcyc-src-addr", &perif->mcyc.saddr);
+		if (rc || !IS_ALIGNED(perif->mcyc.saddr, PERIF_MCYC_ALIGN)) {
+			dev_err(dev, "cannot get 64KB-aligned memory cycle host address\n");
+			return -ENODEV;
+		}
+
+		rc = of_property_read_u32(dev->of_node, "perif-mcyc-size", &perif->mcyc.size);
+		if (rc || !IS_ALIGNED(perif->mcyc.size, PERIF_MCYC_ALIGN)) {
+			dev_err(dev, "cannot get 64KB-aligned memory cycle size\n");
+			return -EINVAL;
+		}
+
+		perif->mcyc.virt = dmam_alloc_coherent(dev, perif->mcyc.size,
+						       &perif->mcyc.taddr, GFP_KERNEL);
+		if (!perif->mcyc.virt) {
+			dev_err(dev, "cannot allocate memory cycle\n");
+			return -ENOMEM;
+		}
+	}
+
+	perif->dma.enable = of_property_read_bool(dev->of_node, "perif-dma-mode");
+	if (perif->dma.enable) {
+		perif->dma.pc_tx_virt = dmam_alloc_coherent(dev, PAGE_SIZE,
+							    &perif->dma.pc_tx_addr, GFP_KERNEL);
+		if (!perif->dma.pc_tx_virt) {
+			dev_err(dev, "cannot allocate posted TX DMA buffer\n");
+			return -ENOMEM;
+		}
+
+		perif->dma.pc_rx_virt = dmam_alloc_coherent(dev, PAGE_SIZE,
+							    &perif->dma.pc_rx_addr, GFP_KERNEL);
+		if (!perif->dma.pc_rx_virt) {
+			dev_err(dev, "cannot allocate posted RX DMA buffer\n");
+			return -ENOMEM;
+		}
+
+		perif->dma.np_tx_virt = dmam_alloc_coherent(dev, PAGE_SIZE,
+							    &perif->dma.np_tx_addr, GFP_KERNEL);
+		if (!perif->dma.np_tx_virt) {
+			dev_err(dev, "cannot allocate non-posted TX DMA buffer\n");
+			return -ENOMEM;
+		}
+	}
+
+	perif->mdev.parent = dev;
+	perif->mdev.minor = MISC_DYNAMIC_MINOR;
+	perif->mdev.name = devm_kasprintf(dev, GFP_KERNEL, "%s-peripheral", DEVICE_NAME);
+	perif->mdev.fops = &ast2600_espi_perif_fops;
+	rc = misc_register(&perif->mdev);
+	if (rc) {
+		dev_err(dev, "cannot register device %s\n", perif->mdev.name);
+		return rc;
+	}
+
+	ast2600_espi_perif_reset(espi);
+
+	if (perif->mmbi.enable) {
+		rc = devm_request_irq(dev, espi->perif.mmbi.irq,
+				      ast2600_espi_perif_mmbi_isr, 0, dev_name(dev), espi);
+		if (rc) {
+			dev_err(dev, "cannot request MMBI IRQ\n");
+			return rc;
+		}
+	}
+
+	return 0;
+}
+
+static int ast2600_espi_perif_remove(struct ast2600_espi *espi)
+{
+	struct ast2600_espi_perif_mmbi *mmbi;
+	struct ast2600_espi_perif *perif;
+	struct device *dev;
+	uint32_t reg;
+	int i;
+
+	dev = espi->dev;
+
+	perif = &espi->perif;
+
+	writel(ESPI_INT_EN_PERIF, espi->regs + ESPI_INT_EN_CLR);
+
+	reg = readl(espi->regs + ESPI_CTRL2);
+	reg |= (ESPI_CTRL2_MCYC_RD_DIS | ESPI_CTRL2_MCYC_WR_DIS);
+	writel(reg, espi->regs + ESPI_CTRL2);
+
+	reg = readl(espi->regs + ESPI_CTRL);
+	reg &= ~(ESPI_CTRL_PERIF_NP_TX_DMA_EN
+		 | ESPI_CTRL_PERIF_PC_TX_DMA_EN
+		 | ESPI_CTRL_PERIF_PC_RX_DMA_EN
+		 | ESPI_CTRL_PERIF_SW_RDY);
+	writel(reg, espi->regs + ESPI_CTRL);
+
+	if (perif->mmbi.enable) {
+		reg = readl(espi->regs + ESPI_MMBI_CTRL);
+		reg &= ~ESPI_MMBI_CTRL_EN;
+		writel(reg, espi->regs + ESPI_MMBI_CTRL);
+
+		for (i = 0; i < PERIF_MMBI_INST_NUM; ++i) {
+			mmbi = &perif->mmbi.inst[i];
+			misc_deregister(&mmbi->b2h_mdev);
+			misc_deregister(&mmbi->h2b_mdev);
+		}
+
+		dmam_free_coherent(dev, perif->mmbi.size, perif->mmbi.virt,
+				   perif->mmbi.taddr);
+	}
+
+	if (perif->mcyc.enable)
+		dmam_free_coherent(dev, perif->mcyc.size, perif->mcyc.virt,
+				   perif->mcyc.taddr);
+
+	if (perif->dma.enable) {
+		dmam_free_coherent(dev, PAGE_SIZE, perif->dma.np_tx_virt,
+				   perif->dma.np_tx_addr);
+		dmam_free_coherent(dev, PAGE_SIZE, perif->dma.pc_tx_virt,
+				   perif->dma.pc_tx_addr);
+		dmam_free_coherent(dev, PAGE_SIZE, perif->dma.pc_rx_virt,
+				   perif->dma.pc_rx_addr);
+	}
+
+	mutex_destroy(&perif->np_tx_mtx);
+	mutex_destroy(&perif->pc_tx_mtx);
+	mutex_destroy(&perif->pc_rx_mtx);
+
+	misc_deregister(&perif->mdev);
+
+	return 0;
+}
+
+/* virtual wire channel (CH1) */
+static long ast2600_espi_vw_ioctl(struct file *fp, unsigned int cmd, unsigned long arg)
+{
+	struct ast2600_espi_vw *vw;
+	struct ast2600_espi *espi;
+	uint32_t gpio, hw_mode;
+
+	vw = container_of(fp->private_data, struct ast2600_espi_vw, mdev);
+	espi = container_of(vw, struct ast2600_espi, vw);
+	gpio = vw->gpio.val;
+	hw_mode = vw->gpio.hw_mode;
+
+	if (hw_mode) {
+		dev_err(espi->dev, "HW mode: vGPIO reflect on physical GPIO. Get state from GPIO driver.\n");
+		return -EFAULT;
+	}
+
+	switch (cmd) {
+	case ASPEED_ESPI_VW_GET_GPIO_VAL:
+		if (put_user(gpio, (uint32_t __user *)arg)) {
+			dev_err(espi->dev, "failed to get vGPIO value\n");
+			return -EFAULT;
+		}
+
+		dev_info(espi->dev, "Get vGPIO value: 0x%x\n", gpio);
+		break;
+
+	case ASPEED_ESPI_VW_PUT_GPIO_VAL:
+		if (get_user(gpio, (uint32_t __user *)arg)) {
+			dev_err(espi->dev, "failed to put vGPIO value\n");
+			return -EFAULT;
+		}
+
+		dev_info(espi->dev, "Put vGPIO value: 0x%x\n", gpio);
+		writel(gpio, espi->regs + ESPI_VW_GPIO_VAL);
+		break;
+
+	default:
+		return -EINVAL;
+	};
+
+	return 0;
+}
+
+static const struct file_operations ast2600_espi_vw_fops = {
+	.owner = THIS_MODULE,
+	.unlocked_ioctl = ast2600_espi_vw_ioctl,
+};
+
+static void ast2600_espi_vw_isr(struct ast2600_espi *espi)
+{
+	struct ast2600_espi_vw *vw;
+	uint32_t sts;
+
+	vw = &espi->vw;
+
+	sts = readl(espi->regs + ESPI_INT_STS);
+
+	if (sts & ESPI_INT_STS_VW_GPIO) {
+		vw->gpio.val = readl(espi->regs + ESPI_VW_GPIO_VAL);
+		writel(ESPI_INT_STS_VW_GPIO, espi->regs + ESPI_INT_STS);
+	} else if (sts & ESPI_INT_STS_VW_SYSEVT) {
+		/* Handle system event */
+		writel(ESPI_INT_STS_VW_SYSEVT, espi->regs + ESPI_INT_STS);
+	} else if (sts & (ESPI_INT_STS_VW_SYSEVT1)) {
+		/* Handle system event1 */
+		writel(ESPI_INT_STS_VW_SYSEVT1, espi->regs + ESPI_INT_STS);
+	}
+}
+
+static void ast2600_espi_vw_reset(struct ast2600_espi *espi)
+{
+	uint32_t reg;
+	struct ast2600_espi_vw *vw = &espi->vw;
+
+	writel(ESPI_INT_EN_VW, espi->regs + ESPI_INT_EN_CLR);
+	writel(ESPI_INT_STS_VW, espi->regs + ESPI_INT_STS);
+
+	writel(vw->gpio.dir, espi->regs + ESPI_VW_GPIO_DIR);
+
+	vw->gpio.val = readl(espi->regs + ESPI_VW_GPIO_VAL);
+
+	reg = readl(espi->regs + ESPI_CTRL2) & ~(ESPI_CTRL2_VW_TX_SORT);
+	writel(reg, espi->regs + ESPI_CTRL2);
+
+	writel(ESPI_INT_EN_VW_GPIO, espi->regs + ESPI_INT_EN);
+
+	reg = readl(espi->regs + ESPI_CTRL)
+	      | ((vw->gpio.hw_mode) ? 0 : ESPI_CTRL_VW_GPIO_SW)
+	      | ESPI_CTRL_VW_SW_RDY;
+	writel(reg, espi->regs + ESPI_CTRL);
+
+	writel(0x0, espi->regs + ESPI_VW_SYSEVT_INT_T0);
+	writel(0x0, espi->regs + ESPI_VW_SYSEVT_INT_T1);
+
+	reg = readl(espi->regs + ESPI_INT_EN);
+	reg |= ESPI_INT_EN_RST_DEASSERT;
+	writel(reg, espi->regs + ESPI_INT_EN);
+
+	writel(0xffffffff, espi->regs + ESPI_VW_SYSEVT_INT_EN);
+	writel(0x1, espi->regs + ESPI_VW_SYSEVT1_INT_EN);
+	writel(0x1, espi->regs + ESPI_VW_SYSEVT1_INT_T0);
+}
+
+static int ast2600_espi_vw_probe(struct ast2600_espi *espi)
+{
+	int rc;
+	struct device *dev = espi->dev;
+	struct ast2600_espi_vw *vw = &espi->vw;
+
+	vw->gpio.hw_mode = of_property_read_bool(dev->of_node, "vw-gpio-hw-mode");
+	of_property_read_u32(dev->of_node, "vw-gpio-direction", &vw->gpio.dir);
+
+	vw->mdev.parent = dev;
+	vw->mdev.minor = MISC_DYNAMIC_MINOR;
+	vw->mdev.name = devm_kasprintf(dev, GFP_KERNEL, "%s-vw", DEVICE_NAME);
+	vw->mdev.fops = &ast2600_espi_vw_fops;
+	rc = misc_register(&vw->mdev);
+	if (rc) {
+		dev_err(dev, "cannot register device %s\n", vw->mdev.name);
+		return rc;
+	}
+
+	ast2600_espi_vw_reset(espi);
+
+	return 0;
+}
+
+static int ast2600_espi_vw_remove(struct ast2600_espi *espi)
+{
+	struct ast2600_espi_vw *vw;
+
+	vw = &espi->vw;
+
+	writel(ESPI_INT_EN_VW, espi->regs + ESPI_INT_EN_CLR);
+
+	misc_deregister(&vw->mdev);
+
+	return 0;
+}
+
+/* out-of-band channel (CH2) */
+static long ast2600_espi_oob_dma_get_rx(struct file *fp,
+					struct ast2600_espi_oob *oob,
+					struct aspeed_espi_ioc *ioc)
+{
+	struct ast2600_espi_oob_dma_rx_desc *d;
+	struct ast2600_espi *espi;
+	struct espi_comm_hdr *hdr;
+	uint32_t wptr, pkt_len;
+	unsigned long flags;
+	uint8_t *pkt;
+	int rc;
+
+	espi = container_of(oob, struct ast2600_espi, oob);
+
+	wptr = FIELD_PREP(ESPI_OOB_RX_DESC_WPTR_WP, readl(espi->regs + ESPI_OOB_RX_DESC_WPTR));
+
+	d = &oob->dma.rxd_virt[wptr];
+
+	if (!d->dirty)
+		return -EFAULT;
+
+	pkt_len = ((d->len) ? d->len : ESPI_MAX_PLD_LEN) + sizeof(struct espi_comm_hdr);
+
+	if (ioc->pkt_len < pkt_len)
+		return -EINVAL;
+
+	pkt = vmalloc(pkt_len);
+	if (!pkt)
+		return -ENOMEM;
+
+	hdr = (struct espi_comm_hdr *)pkt;
+	hdr->cyc = d->cyc;
+	hdr->tag = d->tag;
+	hdr->len_h = d->len >> 8;
+	hdr->len_l = d->len & 0xff;
+	memcpy(hdr + 1, oob->dma.rx_virt + (PAGE_SIZE * wptr), pkt_len - sizeof(*hdr));
+
+	if (copy_to_user((void __user *)ioc->pkt, pkt, pkt_len)) {
+		rc = -EFAULT;
+		goto free_n_out;
+	}
+
+	spin_lock_irqsave(&oob->lock, flags);
+
+	/* make current descriptor available again */
+	d->dirty = 0;
+
+	wptr = (wptr + 1) % OOB_DMA_DESC_NUM;
+	writel(wptr | ESPI_OOB_RX_DESC_WPTR_RECV_EN, espi->regs + ESPI_OOB_RX_DESC_WPTR);
+
+	/* set ready flag base on the next RX descriptor */
+	oob->rx_ready = oob->dma.rxd_virt[wptr].dirty;
+
+	spin_unlock_irqrestore(&oob->lock, flags);
+
+	rc = 0;
+
+free_n_out:
+	vfree(pkt);
+
+	return rc;
+}
+
+static long ast2600_espi_oob_get_rx(struct file *fp,
+				    struct ast2600_espi_oob *oob,
+				    struct aspeed_espi_ioc *ioc)
+{
+	uint32_t reg, cyc, tag, len;
+	struct ast2600_espi *espi;
+	struct espi_comm_hdr *hdr;
+	unsigned long flags;
+	uint32_t pkt_len;
+	uint8_t *pkt;
+	int i, rc;
+
+	espi = container_of(oob, struct ast2600_espi, oob);
+
+	if (fp->f_flags & O_NONBLOCK) {
+		if (!mutex_trylock(&oob->rx_mtx))
+			return -EAGAIN;
+
+		if (!oob->rx_ready) {
+			rc = -ENODATA;
+			goto unlock_mtx_n_out;
+		}
+	} else {
+		mutex_lock(&oob->rx_mtx);
+
+		if (!oob->rx_ready) {
+			rc = wait_event_interruptible(oob->wq, oob->rx_ready);
+			if (rc == -ERESTARTSYS) {
+				rc = -EINTR;
+				goto unlock_mtx_n_out;
+			}
+		}
+	}
+
+	if (oob->dma.enable) {
+		rc = ast2600_espi_oob_dma_get_rx(fp, oob, ioc);
+		goto unlock_mtx_n_out;
+	}
+
+	/*
+	 * common header (i.e. cycle type, tag, and length)
+	 * part is written to HW registers
+	 */
+	reg = readl(espi->regs + ESPI_OOB_RX_CTRL);
+	cyc = FIELD_GET(ESPI_OOB_RX_CTRL_CYC, reg);
+	tag = FIELD_GET(ESPI_OOB_RX_CTRL_TAG, reg);
+	len = FIELD_GET(ESPI_OOB_RX_CTRL_LEN, reg);
+
+	/*
+	 * calculate the length of the rest part of the
+	 * eSPI packet to be read from HW and copied to
+	 * user space.
+	 */
+	pkt_len = ((len) ? len : ESPI_MAX_PLD_LEN) + sizeof(struct espi_comm_hdr);
+
+	if (ioc->pkt_len < pkt_len) {
+		rc = -EINVAL;
+		goto unlock_mtx_n_out;
+	}
+
+	pkt = vmalloc(pkt_len);
+	if (!pkt) {
+		rc = -ENOMEM;
+		goto unlock_mtx_n_out;
+	}
+
+	hdr = (struct espi_comm_hdr *)pkt;
+	hdr->cyc = cyc;
+	hdr->tag = tag;
+	hdr->len_h = len >> 8;
+	hdr->len_l = len & 0xff;
+
+	for (i = sizeof(*hdr); i < pkt_len; ++i)
+		pkt[i] = readl(espi->regs + ESPI_OOB_RX_DATA) & 0xff;
+
+	if (copy_to_user((void __user *)ioc->pkt, pkt, pkt_len)) {
+		rc = -EFAULT;
+		goto free_n_out;
+	}
+
+	spin_lock_irqsave(&oob->lock, flags);
+
+	writel(ESPI_OOB_RX_CTRL_SERV_PEND, espi->regs + ESPI_OOB_RX_CTRL);
+	oob->rx_ready = 0;
+
+	spin_unlock_irqrestore(&oob->lock, flags);
+
+	rc = 0;
+
+free_n_out:
+	vfree(pkt);
+
+unlock_mtx_n_out:
+	mutex_unlock(&oob->rx_mtx);
+
+	return rc;
+}
+
+static long ast2600_espi_oob_dma_put_tx(struct file *fp,
+					struct ast2600_espi_oob *oob,
+					struct aspeed_espi_ioc *ioc)
+{
+	struct ast2600_espi_oob_dma_tx_desc *d;
+	struct ast2600_espi *espi;
+	struct espi_comm_hdr *hdr;
+	uint32_t rptr, wptr;
+	uint8_t *pkt;
+	int rc;
+
+	espi = container_of(oob, struct ast2600_espi, oob);
+
+	pkt = vzalloc(ioc->pkt_len);
+	if (!pkt)
+		return -ENOMEM;
+
+	hdr = (struct espi_comm_hdr *)pkt;
+
+	if (copy_from_user(pkt, (void __user *)ioc->pkt, ioc->pkt_len)) {
+		rc = -EFAULT;
+		goto free_n_out;
+	}
+
+	/* kick HW to update descriptor read/write pointer */
+	writel(ESPI_OOB_TX_DESC_RPTR_UPDATE, espi->regs + ESPI_OOB_TX_DESC_RPTR);
+
+	rptr = readl(espi->regs + ESPI_OOB_TX_DESC_RPTR);
+	wptr = readl(espi->regs + ESPI_OOB_TX_DESC_WPTR);
+
+	if (((wptr + 1) % OOB_DMA_DESC_NUM) == rptr) {
+		rc = -EBUSY;
+		goto free_n_out;
+	}
+
+	d = &oob->dma.txd_virt[wptr];
+	d->cyc = hdr->cyc;
+	d->tag = hdr->tag;
+	d->len = (hdr->len_h << 8) | (hdr->len_l & 0xff);
+	d->msg_type = OOB_DMA_DESC_CUSTOM;
+
+	memcpy(oob->dma.tx_virt + (PAGE_SIZE * wptr), hdr + 1,  ioc->pkt_len - sizeof(*hdr));
+
+	dma_wmb();
+
+	wptr = (wptr + 1) % OOB_DMA_DESC_NUM;
+	writel(wptr | ESPI_OOB_TX_DESC_WPTR_SEND_EN, espi->regs + ESPI_OOB_TX_DESC_WPTR);
+
+	rc = 0;
+
+free_n_out:
+	vfree(pkt);
+
+	return rc;
+}
+
+static long ast2600_espi_oob_put_tx(struct file *fp,
+				    struct ast2600_espi_oob *oob,
+				    struct aspeed_espi_ioc *ioc)
+{
+	uint32_t reg, cyc, tag, len;
+	struct ast2600_espi *espi;
+	struct espi_comm_hdr *hdr;
+	uint8_t *pkt;
+	int i, rc;
+
+	espi = container_of(oob, struct ast2600_espi, oob);
+
+	if (!mutex_trylock(&oob->tx_mtx))
+		return -EAGAIN;
+
+	if (oob->dma.enable) {
+		rc = ast2600_espi_oob_dma_put_tx(fp, oob, ioc);
+		goto unlock_mtx_n_out;
+	}
+
+	reg = readl(espi->regs + ESPI_OOB_TX_CTRL);
+	if (reg & ESPI_OOB_TX_CTRL_TRIG_PEND) {
+		rc = -EBUSY;
+		goto unlock_mtx_n_out;
+	}
+
+	if (ioc->pkt_len > ESPI_MAX_PKT_LEN) {
+		rc = -EINVAL;
+		goto unlock_mtx_n_out;
+	}
+
+	pkt = vmalloc(ioc->pkt_len);
+	if (!pkt) {
+		rc = -ENOMEM;
+		goto unlock_mtx_n_out;
+	}
+
+	hdr = (struct espi_comm_hdr *)pkt;
+
+	if (copy_from_user(pkt, (void __user *)ioc->pkt, ioc->pkt_len)) {
+		rc = -EFAULT;
+		goto free_n_out;
+	}
+
+	/*
+	 * common header (i.e. cycle type, tag, and length)
+	 * part is written to HW registers
+	 */
+	for (i = sizeof(*hdr); i < ioc->pkt_len; ++i)
+		writel(pkt[i], espi->regs + ESPI_OOB_TX_DATA);
+
+	cyc = hdr->cyc;
+	tag = hdr->tag;
+	len = (hdr->len_h << 8) | (hdr->len_l & 0xff);
+
+	reg = FIELD_PREP(ESPI_OOB_TX_CTRL_CYC, cyc)
+	      | FIELD_PREP(ESPI_OOB_TX_CTRL_TAG, tag)
+	      | FIELD_PREP(ESPI_OOB_TX_CTRL_LEN, len)
+	      | ESPI_OOB_TX_CTRL_TRIG_PEND;
+	writel(reg, espi->regs + ESPI_OOB_TX_CTRL);
+
+	rc = 0;
+
+free_n_out:
+	vfree(pkt);
+
+unlock_mtx_n_out:
+	mutex_unlock(&oob->tx_mtx);
+
+	return rc;
+}
+
+static long ast2600_espi_oob_ioctl(struct file *fp, unsigned int cmd, unsigned long arg)
+{
+	struct ast2600_espi_oob *oob;
+	struct aspeed_espi_ioc ioc;
+
+	oob = container_of(fp->private_data, struct ast2600_espi_oob, mdev);
+
+	if (copy_from_user(&ioc, (void __user *)arg, sizeof(ioc)))
+		return -EFAULT;
+
+	if (ioc.pkt_len > ESPI_MAX_PKT_LEN)
+		return -EINVAL;
+
+	switch (cmd) {
+	case ASPEED_ESPI_OOB_GET_RX:
+		return ast2600_espi_oob_get_rx(fp, oob, &ioc);
+	case ASPEED_ESPI_OOB_PUT_TX:
+		return ast2600_espi_oob_put_tx(fp, oob, &ioc);
+	};
+
+	return -EINVAL;
+}
+
+static const struct file_operations ast2600_espi_oob_fops = {
+	.owner = THIS_MODULE,
+	.unlocked_ioctl = ast2600_espi_oob_ioctl,
+};
+
+static void ast2600_espi_oob_isr(struct ast2600_espi *espi)
+{
+	struct ast2600_espi_oob *oob;
+	unsigned long flags;
+	uint32_t sts;
+
+	oob = &espi->oob;
+
+	sts = readl(espi->regs + ESPI_INT_STS);
+
+	if (sts & ESPI_INT_STS_OOB_RX_CMPLT) {
+		writel(ESPI_INT_STS_OOB_RX_CMPLT, espi->regs + ESPI_INT_STS);
+
+		spin_lock_irqsave(&oob->lock, flags);
+		oob->rx_ready = true;
+		spin_unlock_irqrestore(&oob->lock, flags);
+
+		wake_up_interruptible(&oob->wq);
+	}
+}
+
+static void ast2600_espi_oob_reset(struct ast2600_espi *espi)
+{
+	struct ast2600_espi_oob *oob;
+	dma_addr_t tx_addr, rx_addr;
+	uint32_t reg;
+	int i;
+
+	writel(ESPI_INT_EN_OOB, espi->regs + ESPI_INT_EN_CLR);
+	writel(ESPI_INT_STS_OOB, espi->regs + ESPI_INT_STS);
+
+	reg = readl(espi->regs + ESPI_CTRL);
+	reg &= ~(ESPI_CTRL_OOB_TX_SW_RST
+		 | ESPI_CTRL_OOB_RX_SW_RST
+		 | ESPI_CTRL_OOB_TX_DMA_EN
+		 | ESPI_CTRL_OOB_RX_DMA_EN
+		 | ESPI_CTRL_OOB_SW_RDY);
+	writel(reg, espi->regs + ESPI_CTRL);
+
+	udelay(1);
+
+	reg |= (ESPI_CTRL_OOB_TX_SW_RST | ESPI_CTRL_OOB_RX_SW_RST);
+	writel(reg, espi->regs + ESPI_CTRL);
+
+	oob = &espi->oob;
+
+	if (oob->dma.enable) {
+		tx_addr = oob->dma.tx_addr;
+		rx_addr = oob->dma.rx_addr;
+
+		for (i = 0; i < OOB_DMA_DESC_NUM; ++i) {
+			oob->dma.txd_virt[i].data_addr = tx_addr;
+			tx_addr += PAGE_SIZE;
+
+			oob->dma.rxd_virt[i].data_addr = rx_addr;
+			oob->dma.rxd_virt[i].dirty = 0;
+			rx_addr += PAGE_SIZE;
+		}
+
+		writel(oob->dma.txd_addr, espi->regs + ESPI_OOB_TX_DMA);
+		writel(OOB_DMA_RPTR_KEY, espi->regs + ESPI_OOB_TX_DESC_RPTR);
+		writel(0x0, espi->regs + ESPI_OOB_TX_DESC_WPTR);
+		writel(OOB_DMA_DESC_NUM, espi->regs + ESPI_OOB_TX_DESC_NUM);
+
+		writel(oob->dma.rxd_addr, espi->regs + ESPI_OOB_RX_DMA);
+		writel(OOB_DMA_RPTR_KEY, espi->regs + ESPI_OOB_RX_DESC_RPTR);
+		writel(0x0, espi->regs + ESPI_OOB_RX_DESC_WPTR);
+		writel(OOB_DMA_DESC_NUM, espi->regs + ESPI_OOB_RX_DESC_NUM);
+
+		reg = readl(espi->regs + ESPI_CTRL)
+		      | ESPI_CTRL_OOB_TX_DMA_EN
+		      | ESPI_CTRL_OOB_RX_DMA_EN;
+		writel(reg, espi->regs + ESPI_CTRL);
+
+		/* activate RX DMA to make OOB_FREE */
+		writel(ESPI_OOB_RX_DESC_WPTR_RECV_EN, espi->regs + ESPI_OOB_RX_DESC_WPTR);
+	}
+
+	writel(ESPI_INT_EN_OOB_RX_CMPLT, espi->regs + ESPI_INT_EN);
+
+	reg = readl(espi->regs + ESPI_CTRL) | ESPI_CTRL_OOB_SW_RDY;
+	writel(reg, espi->regs + ESPI_CTRL);
+}
+
+static int ast2600_espi_oob_probe(struct ast2600_espi *espi)
+{
+	struct ast2600_espi_oob *oob;
+	struct device *dev;
+	int rc;
+
+	dev = espi->dev;
+
+	oob = &espi->oob;
+
+	init_waitqueue_head(&oob->wq);
+
+	spin_lock_init(&oob->lock);
+
+	mutex_init(&oob->tx_mtx);
+	mutex_init(&oob->rx_mtx);
+
+	oob->dma.enable = of_property_read_bool(dev->of_node, "oob-dma-mode");
+	if (oob->dma.enable) {
+		oob->dma.txd_virt = dmam_alloc_coherent(dev, sizeof(*oob->dma.txd_virt) * OOB_DMA_DESC_NUM, &oob->dma.txd_addr, GFP_KERNEL);
+		if (!oob->dma.txd_virt) {
+			dev_err(dev, "cannot allocate DMA TX descriptor\n");
+			return -ENOMEM;
+		}
+		oob->dma.tx_virt = dmam_alloc_coherent(dev, PAGE_SIZE * OOB_DMA_DESC_NUM, &oob->dma.tx_addr, GFP_KERNEL);
+		if (!oob->dma.tx_virt) {
+			dev_err(dev, "cannot allocate DMA TX buffer\n");
+			return -ENOMEM;
+		}
+
+		oob->dma.rxd_virt = dmam_alloc_coherent(dev, sizeof(*oob->dma.rxd_virt) * OOB_DMA_DESC_NUM, &oob->dma.rxd_addr, GFP_KERNEL);
+		if (!oob->dma.rxd_virt) {
+			dev_err(dev, "cannot allocate DMA RX descriptor\n");
+			return -ENOMEM;
+		}
+
+		oob->dma.rx_virt = dmam_alloc_coherent(dev, PAGE_SIZE * OOB_DMA_DESC_NUM, &oob->dma.rx_addr, GFP_KERNEL);
+		if (!oob->dma.rx_virt) {
+			dev_err(dev, "cannot allocate DMA TX buffer\n");
+			return -ENOMEM;
+		}
+	}
+
+	oob->mdev.parent = dev;
+	oob->mdev.minor = MISC_DYNAMIC_MINOR;
+	oob->mdev.name = devm_kasprintf(dev, GFP_KERNEL, "%s-oob", DEVICE_NAME);
+	oob->mdev.fops = &ast2600_espi_oob_fops;
+	rc = misc_register(&oob->mdev);
+	if (rc) {
+		dev_err(dev, "cannot register device %s\n", oob->mdev.name);
+		return rc;
+	}
+
+	ast2600_espi_oob_reset(espi);
+
+	return 0;
+}
+
+static int ast2600_espi_oob_remove(struct ast2600_espi *espi)
+{
+	struct ast2600_espi_oob *oob;
+	struct device *dev;
+	uint32_t reg;
+
+	dev = espi->dev;
+
+	oob = &espi->oob;
+
+	writel(ESPI_INT_EN_OOB, espi->regs + ESPI_INT_EN_CLR);
+
+	reg = readl(espi->regs + ESPI_CTRL);
+	reg &= ~(ESPI_CTRL_OOB_TX_DMA_EN
+		 | ESPI_CTRL_OOB_RX_DMA_EN
+		 | ESPI_CTRL_OOB_SW_RDY);
+	writel(reg, espi->regs + ESPI_CTRL);
+
+	if (oob->dma.enable) {
+		dmam_free_coherent(dev, sizeof(*oob->dma.txd_virt) * OOB_DMA_DESC_NUM,
+				   oob->dma.txd_virt, oob->dma.txd_addr);
+		dmam_free_coherent(dev, PAGE_SIZE * OOB_DMA_DESC_NUM,
+				   oob->dma.tx_virt, oob->dma.tx_addr);
+		dmam_free_coherent(dev, sizeof(*oob->dma.rxd_virt) * OOB_DMA_DESC_NUM,
+				   oob->dma.rxd_virt, oob->dma.rxd_addr);
+		dmam_free_coherent(dev, PAGE_SIZE * OOB_DMA_DESC_NUM,
+				   oob->dma.rx_virt, oob->dma.rx_addr);
+	}
+
+	mutex_destroy(&oob->tx_mtx);
+	mutex_destroy(&oob->rx_mtx);
+
+	misc_deregister(&oob->mdev);
+
+	return 0;
+}
+
+/* flash channel (CH3) */
+static long ast2600_espi_flash_get_rx(struct file *fp,
+				      struct ast2600_espi_flash *flash,
+				      struct aspeed_espi_ioc *ioc)
+{
+	uint32_t reg, cyc, tag, len;
+	struct ast2600_espi *espi;
+	struct espi_comm_hdr *hdr;
+	unsigned long flags;
+	uint32_t pkt_len;
+	uint8_t *pkt;
+	int i, rc;
+
+	rc = 0;
+
+	espi = container_of(flash, struct ast2600_espi, flash);
+
+	if (fp->f_flags & O_NONBLOCK) {
+		if (!mutex_trylock(&flash->rx_mtx))
+			return -EAGAIN;
+
+		if (!flash->rx_ready) {
+			rc = -ENODATA;
+			goto unlock_mtx_n_out;
+		}
+	} else {
+		mutex_lock(&flash->rx_mtx);
+
+		if (!flash->rx_ready) {
+			rc = wait_event_interruptible(flash->wq, flash->rx_ready);
+			if (rc == -ERESTARTSYS) {
+				rc = -EINTR;
+				goto unlock_mtx_n_out;
+			}
+		}
+	}
+
+	/*
+	 * common header (i.e. cycle type, tag, and length)
+	 * part is written to HW registers
+	 */
+	reg = readl(espi->regs + ESPI_FLASH_RX_CTRL);
+	cyc = FIELD_GET(ESPI_FLASH_RX_CTRL_CYC, reg);
+	tag = FIELD_GET(ESPI_FLASH_RX_CTRL_TAG, reg);
+	len = FIELD_GET(ESPI_FLASH_RX_CTRL_LEN, reg);
+
+	/*
+	 * calculate the length of the rest part of the
+	 * eSPI packet to be read from HW and copied to
+	 * user space.
+	 */
+	switch (cyc) {
+	case ESPI_FLASH_WRITE:
+		pkt_len = ((len) ? len : ESPI_MAX_PLD_LEN) +
+			  sizeof(struct espi_flash_rwe);
+		break;
+	case ESPI_FLASH_READ:
+	case ESPI_FLASH_ERASE:
+		pkt_len = sizeof(struct espi_flash_rwe);
+		break;
+	case ESPI_FLASH_SUC_CMPLT_D_MIDDLE:
+	case ESPI_FLASH_SUC_CMPLT_D_FIRST:
+	case ESPI_FLASH_SUC_CMPLT_D_LAST:
+	case ESPI_FLASH_SUC_CMPLT_D_ONLY:
+		pkt_len = ((len) ? len : ESPI_MAX_PLD_LEN) +
+			  sizeof(struct espi_flash_cmplt);
+		break;
+	case ESPI_FLASH_SUC_CMPLT:
+	case ESPI_FLASH_UNSUC_CMPLT:
+		pkt_len = sizeof(struct espi_flash_cmplt);
+		break;
+	default:
+		rc = -EFAULT;
+		goto unlock_mtx_n_out;
+	}
+
+	if (ioc->pkt_len < pkt_len) {
+		rc = -EINVAL;
+		goto unlock_mtx_n_out;
+	}
+
+	pkt = vmalloc(pkt_len);
+	if (!pkt) {
+		rc = -ENOMEM;
+		goto unlock_mtx_n_out;
+	}
+
+	hdr = (struct espi_comm_hdr *)pkt;
+	hdr->cyc = cyc;
+	hdr->tag = tag;
+	hdr->len_h = len >> 8;
+	hdr->len_l = len & 0xff;
+
+	if (flash->dma.enable) {
+		memcpy(hdr + 1, flash->dma.rx_virt, pkt_len - sizeof(*hdr));
+	} else {
+		for (i = sizeof(*hdr); i < pkt_len; ++i)
+			pkt[i] = readl(espi->regs + ESPI_FLASH_RX_DATA) & 0xff;
+	}
+
+	if (copy_to_user((void __user *)ioc->pkt, pkt, pkt_len)) {
+		rc = -EFAULT;
+		goto free_n_out;
+	}
+
+	spin_lock_irqsave(&flash->lock, flags);
+
+	writel(ESPI_FLASH_RX_CTRL_SERV_PEND, espi->regs + ESPI_FLASH_RX_CTRL);
+	flash->rx_ready = 0;
+
+	spin_unlock_irqrestore(&flash->lock, flags);
+
+	rc = 0;
+
+free_n_out:
+	vfree(pkt);
+
+unlock_mtx_n_out:
+	mutex_unlock(&flash->rx_mtx);
+
+	return rc;
+}
+
+static long ast2600_espi_flash_put_tx(struct file *fp,
+				      struct ast2600_espi_flash *flash,
+				      struct aspeed_espi_ioc *ioc)
+{
+	uint32_t reg, cyc, tag, len;
+	struct ast2600_espi *espi;
+	struct espi_comm_hdr *hdr;
+	uint8_t *pkt;
+	int i, rc;
+
+	espi = container_of(flash, struct ast2600_espi, flash);
+
+	if (!mutex_trylock(&flash->tx_mtx))
+		return -EAGAIN;
+
+	reg = readl(espi->regs + ESPI_FLASH_TX_CTRL);
+	if (reg & ESPI_FLASH_TX_CTRL_TRIG_PEND) {
+		rc = -EBUSY;
+		goto unlock_mtx_n_out;
+	}
+
+	pkt = vmalloc(ioc->pkt_len);
+	if (!pkt) {
+		rc = -ENOMEM;
+		goto unlock_mtx_n_out;
+	}
+
+	hdr = (struct espi_comm_hdr *)pkt;
+
+	if (copy_from_user(pkt, (void __user *)ioc->pkt, ioc->pkt_len)) {
+		rc = -EFAULT;
+		goto free_n_out;
+	}
+
+	/*
+	 * common header (i.e. cycle type, tag, and length)
+	 * part is written to HW registers
+	 */
+	if (flash->dma.enable) {
+		memcpy(flash->dma.tx_virt, hdr + 1, ioc->pkt_len - sizeof(*hdr));
+		dma_wmb();
+	} else {
+		for (i = sizeof(*hdr); i < ioc->pkt_len; ++i)
+			writel(pkt[i], espi->regs + ESPI_FLASH_TX_DATA);
+	}
+
+	cyc = hdr->cyc;
+	tag = hdr->tag;
+	len = (hdr->len_h << 8) | (hdr->len_l & 0xff);
+
+	reg = FIELD_PREP(ESPI_FLASH_TX_CTRL_CYC, cyc)
+	      | FIELD_PREP(ESPI_FLASH_TX_CTRL_TAG, tag)
+	      | FIELD_PREP(ESPI_FLASH_TX_CTRL_LEN, len)
+	      | ESPI_FLASH_TX_CTRL_TRIG_PEND;
+	writel(reg, espi->regs + ESPI_FLASH_TX_CTRL);
+
+	rc = 0;
+
+free_n_out:
+	vfree(pkt);
+
+unlock_mtx_n_out:
+	mutex_unlock(&flash->tx_mtx);
+
+	return rc;
+}
+
+static long ast2600_espi_flash_ioctl(struct file *fp, unsigned int cmd, unsigned long arg)
+{
+	struct ast2600_espi_flash *flash;
+	struct aspeed_espi_ioc ioc;
+
+	flash = container_of(fp->private_data, struct ast2600_espi_flash, mdev);
+
+	if (copy_from_user(&ioc, (void __user *)arg, sizeof(ioc)))
+		return -EFAULT;
+
+	if (ioc.pkt_len > ESPI_MAX_PKT_LEN)
+		return -EINVAL;
+
+	switch (cmd) {
+	case ASPEED_ESPI_FLASH_GET_RX:
+		return ast2600_espi_flash_get_rx(fp, flash, &ioc);
+	case ASPEED_ESPI_FLASH_PUT_TX:
+		return ast2600_espi_flash_put_tx(fp, flash, &ioc);
+	default:
+		break;
+	};
+
+	return -EINVAL;
+}
+
+static const struct file_operations ast2600_espi_flash_fops = {
+	.owner = THIS_MODULE,
+	.unlocked_ioctl = ast2600_espi_flash_ioctl,
+};
+
+static void ast2600_espi_flash_isr(struct ast2600_espi *espi)
+{
+	struct ast2600_espi_flash *flash;
+	unsigned long flags;
+	uint32_t sts;
+
+	flash = &espi->flash;
+
+	sts = readl(espi->regs + ESPI_INT_STS);
+
+	if (sts & ESPI_INT_STS_FLASH_RX_CMPLT) {
+		writel(ESPI_INT_STS_FLASH_RX_CMPLT, espi->regs + ESPI_INT_STS);
+
+		spin_lock_irqsave(&flash->lock, flags);
+		flash->rx_ready = true;
+		spin_unlock_irqrestore(&flash->lock, flags);
+
+		wake_up_interruptible(&flash->wq);
+	}
+}
+
+static void ast2600_espi_flash_reset(struct ast2600_espi *espi)
+{
+	struct ast2600_espi_flash *flash;
+	uint32_t reg;
+
+	flash = &espi->flash;
+
+	writel(ESPI_INT_EN_FLASH, espi->regs + ESPI_INT_EN_CLR);
+	writel(ESPI_INT_STS_FLASH, espi->regs + ESPI_INT_STS);
+
+	reg = readl(espi->regs + ESPI_CTRL);
+	reg &= ~(ESPI_CTRL_FLASH_TX_SW_RST
+		 | ESPI_CTRL_FLASH_RX_SW_RST
+		 | ESPI_CTRL_FLASH_TX_DMA_EN
+		 | ESPI_CTRL_FLASH_RX_DMA_EN
+		 | ESPI_CTRL_FLASH_SW_RDY);
+	writel(reg, espi->regs + ESPI_CTRL);
+
+	udelay(1);
+
+	reg |= (ESPI_CTRL_FLASH_TX_SW_RST | ESPI_CTRL_FLASH_RX_SW_RST);
+	writel(reg, espi->regs + ESPI_CTRL);
+
+	reg = readl(espi->regs + ESPI_CTRL) & ~ESPI_CTRL_FLASH_SAFS_MODE;
+	reg |= FIELD_PREP(ESPI_CTRL_FLASH_SAFS_MODE, flash->safs.mode);
+	writel(reg, espi->regs + ESPI_CTRL);
+
+	if (flash->safs.mode == SAFS_MODE_MIX) {
+		reg = FIELD_PREP(ESPI_FLASH_SAFS_TADDR_BASE, flash->safs.taddr >> 24)
+		      | FIELD_PREP(ESPI_FLASH_SAFS_TADDR_MASK, (~(flash->safs.size - 1)) >> 24);
+		writel(reg, espi->regs + ESPI_FLASH_SAFS_TADDR);
+	}
+
+	if (flash->dma.enable) {
+		writel(flash->dma.tx_addr, espi->regs + ESPI_FLASH_TX_DMA);
+		writel(flash->dma.rx_addr, espi->regs + ESPI_FLASH_RX_DMA);
+
+		reg = readl(espi->regs + ESPI_CTRL)
+		      | ESPI_CTRL_FLASH_TX_DMA_EN
+		      | ESPI_CTRL_FLASH_RX_DMA_EN;
+		writel(reg, espi->regs + ESPI_CTRL);
+	}
+
+	writel(ESPI_INT_EN_FLASH_RX_CMPLT, espi->regs + ESPI_INT_EN);
+
+	reg = readl(espi->regs + ESPI_CTRL) | ESPI_CTRL_FLASH_SW_RDY;
+	writel(reg, espi->regs + ESPI_CTRL);
+}
+
+static int ast2600_espi_flash_probe(struct ast2600_espi *espi)
+{
+	struct ast2600_espi_flash *flash;
+	struct device *dev;
+	int rc;
+
+	dev = espi->dev;
+
+	flash = &espi->flash;
+
+	init_waitqueue_head(&flash->wq);
+
+	spin_lock_init(&flash->lock);
+
+	mutex_init(&flash->tx_mtx);
+	mutex_init(&flash->rx_mtx);
+
+	flash->safs.mode = SAFS_MODE_HW;
+
+	of_property_read_u32(dev->of_node, "flash-safs-mode", &flash->safs.mode);
+	if (flash->safs.mode == SAFS_MODE_MIX) {
+		rc = of_property_read_u32(dev->of_node, "flash-safs-tgt-addr", &flash->safs.taddr);
+		if (rc || !IS_ALIGNED(flash->safs.taddr, FLASH_SAFS_ALIGN)) {
+			dev_err(dev, "cannot get 16MB-aligned SAFS target address\n");
+			return -ENODEV;
+		}
+
+		rc = of_property_read_u32(dev->of_node, "flash-safs-size", &flash->safs.size);
+		if (rc || !IS_ALIGNED(flash->safs.size, FLASH_SAFS_ALIGN)) {
+			dev_err(dev, "cannot get 16MB-aligned SAFS size\n");
+			return -ENODEV;
+		}
+	}
+
+	flash->dma.enable = of_property_read_bool(dev->of_node, "flash-dma-mode");
+	if (flash->dma.enable) {
+		flash->dma.tx_virt = dmam_alloc_coherent(dev, PAGE_SIZE, &flash->dma.tx_addr, GFP_KERNEL);
+		if (!flash->dma.tx_virt) {
+			dev_err(dev, "cannot allocate DMA TX buffer\n");
+			return -ENOMEM;
+		}
+
+		flash->dma.rx_virt = dmam_alloc_coherent(dev, PAGE_SIZE, &flash->dma.rx_addr, GFP_KERNEL);
+		if (!flash->dma.rx_virt) {
+			dev_err(dev, "cannot allocate DMA RX buffer\n");
+			return -ENOMEM;
+		}
+	}
+
+	flash->mdev.parent = dev;
+	flash->mdev.minor = MISC_DYNAMIC_MINOR;
+	flash->mdev.name = devm_kasprintf(dev, GFP_KERNEL, "%s-flash", DEVICE_NAME);
+	flash->mdev.fops = &ast2600_espi_flash_fops;
+	rc = misc_register(&flash->mdev);
+	if (rc) {
+		dev_err(dev, "cannot register device %s\n", flash->mdev.name);
+		return rc;
+	}
+
+	ast2600_espi_flash_reset(espi);
+
+	return 0;
+}
+
+static int ast2600_espi_flash_remove(struct ast2600_espi *espi)
+{
+	struct ast2600_espi_flash *flash;
+	struct device *dev;
+	uint32_t reg;
+
+	dev = espi->dev;
+
+	flash = &espi->flash;
+
+	writel(ESPI_INT_EN_FLASH, espi->regs + ESPI_INT_EN_CLR);
+
+	reg = readl(espi->regs + ESPI_CTRL);
+	reg &= ~(ESPI_CTRL_FLASH_TX_DMA_EN
+		 | ESPI_CTRL_FLASH_RX_DMA_EN
+		 | ESPI_CTRL_FLASH_SW_RDY);
+	writel(reg, espi->regs + ESPI_CTRL);
+
+	if (flash->dma.enable) {
+		dmam_free_coherent(dev, PAGE_SIZE, flash->dma.tx_virt, flash->dma.tx_addr);
+		dmam_free_coherent(dev, PAGE_SIZE, flash->dma.rx_virt, flash->dma.rx_addr);
+	}
+
+	mutex_destroy(&flash->tx_mtx);
+	mutex_destroy(&flash->rx_mtx);
+
+	misc_deregister(&flash->mdev);
+
+	return 0;
+}
+
+/* global control */
+static irqreturn_t ast2600_espi_isr(int irq, void *arg)
+{
+	struct ast2600_espi *espi;
+	uint32_t sts;
+
+	espi = (struct ast2600_espi *)arg;
+
+	sts = readl(espi->regs + ESPI_INT_STS);
+	if (!sts)
+		return IRQ_NONE;
+
+	if (sts & ESPI_INT_STS_PERIF)
+		ast2600_espi_perif_isr(espi);
+
+	if (sts & ESPI_INT_STS_VW)
+		ast2600_espi_vw_isr(espi);
+
+	if (sts & ESPI_INT_STS_OOB)
+		ast2600_espi_oob_isr(espi);
+
+	if (sts & ESPI_INT_STS_FLASH)
+		ast2600_espi_flash_isr(espi);
+
+	if (sts & ESPI_INT_STS_RST_DEASSERT) {
+		/* this will clear all interrupt enable and status */
+		reset_control_assert(espi->rst);
+		reset_control_deassert(espi->rst);
+
+		ast2600_espi_perif_sw_reset(espi);
+		ast2600_espi_perif_reset(espi);
+		ast2600_espi_vw_reset(espi);
+		ast2600_espi_oob_reset(espi);
+		ast2600_espi_flash_reset(espi);
+
+		/* re-enable eSPI_RESET# interrupt */
+		writel(ESPI_INT_EN_RST_DEASSERT, espi->regs + ESPI_INT_EN);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int ast2600_espi_probe(struct platform_device *pdev)
+{
+	struct ast2600_espi *espi;
+	struct resource *res;
+	struct device *dev;
+	int rc;
+
+	dev = &pdev->dev;
+
+	espi = devm_kzalloc(dev, sizeof(*espi), GFP_KERNEL);
+	if (!espi)
+		return -ENOMEM;
+
+	espi->dev = dev;
+
+	rc = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(64));
+	if (rc) {
+		dev_err(dev, "cannot set 64-bits DMA mask\n");
+		return rc;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(dev, "cannot get resource\n");
+		return -ENODEV;
+	}
+
+	espi->regs = devm_ioremap_resource(dev, res);
+	if (IS_ERR(espi->regs)) {
+		dev_err(dev, "cannot map registers\n");
+		return PTR_ERR(espi->regs);
+	}
+
+	espi->irq = platform_get_irq(pdev, 0);
+	if (espi->irq < 0) {
+		dev_err(dev, "cannot get IRQ number\n");
+		return -ENODEV;
+	}
+
+	espi->rst = devm_reset_control_get_exclusive_by_index(dev, 0);
+	if (IS_ERR(espi->rst)) {
+		dev_err(dev, "cannot get reset control\n");
+		return PTR_ERR(espi->rst);
+	}
+
+	espi->clk = devm_clk_get(dev, NULL);
+	if (IS_ERR(espi->clk)) {
+		dev_err(dev, "cannot get clock control\n");
+		return PTR_ERR(espi->clk);
+	}
+
+	rc = clk_prepare_enable(espi->clk);
+	if (rc) {
+		dev_err(dev, "cannot enable clocks\n");
+		return rc;
+	}
+
+	writel(ESPI_INT_EN_RST_DEASSERT, espi->regs + ESPI_INT_EN_CLR);
+
+	rc = ast2600_espi_perif_probe(espi);
+	if (rc) {
+		dev_err(dev, "cannot init peripheral channel, rc=%d\n", rc);
+		return rc;
+	}
+
+	rc = ast2600_espi_vw_probe(espi);
+	if (rc) {
+		dev_err(dev, "cannot init vw channel, rc=%d\n", rc);
+		goto err_remove_perif;
+	}
+
+	rc = ast2600_espi_oob_probe(espi);
+	if (rc) {
+		dev_err(dev, "cannot init oob channel, rc=%d\n", rc);
+		goto err_remove_vw;
+	}
+
+	rc = ast2600_espi_flash_probe(espi);
+	if (rc) {
+		dev_err(dev, "cannot init flash channel, rc=%d\n", rc);
+		goto err_remove_oob;
+	}
+
+	rc = devm_request_irq(dev, espi->irq, ast2600_espi_isr, 0, dev_name(dev), espi);
+	if (rc) {
+		dev_err(dev, "cannot request IRQ\n");
+		goto err_remove_flash;
+	}
+
+	writel(ESPI_INT_EN_RST_DEASSERT, espi->regs + ESPI_INT_EN);
+
+	platform_set_drvdata(pdev, espi);
+
+	dev_info(dev, "module loaded\n");
+
+	return 0;
+
+err_remove_flash:
+	ast2600_espi_flash_remove(espi);
+err_remove_oob:
+	ast2600_espi_oob_remove(espi);
+err_remove_vw:
+	ast2600_espi_vw_remove(espi);
+err_remove_perif:
+	ast2600_espi_perif_remove(espi);
+
+	return rc;
+}
+
+static void ast2600_espi_remove(struct platform_device *pdev)
+{
+	struct ast2600_espi *espi;
+	struct device *dev;
+	int rc;
+
+	dev = &pdev->dev;
+
+	espi = platform_get_drvdata(pdev);
+
+	writel(ESPI_INT_EN_RST_DEASSERT, espi->regs + ESPI_INT_EN_CLR);
+
+	rc = ast2600_espi_perif_remove(espi);
+	if (rc)
+		dev_warn(dev, "cannot remove peripheral channel, rc=%d\n", rc);
+
+	rc = ast2600_espi_vw_remove(espi);
+	if (rc)
+		dev_warn(dev, "cannot remove peripheral channel, rc=%d\n", rc);
+
+	rc = ast2600_espi_oob_remove(espi);
+	if (rc)
+		dev_warn(dev, "cannot remove peripheral channel, rc=%d\n", rc);
+
+	rc = ast2600_espi_flash_remove(espi);
+	if (rc)
+		dev_warn(dev, "cannot remove peripheral channel, rc=%d\n", rc);
+}
+
+static const struct of_device_id ast2600_espi_of_matches[] = {
+	{ .compatible = "aspeed,ast2600-espi" },
+	{ },
+};
+
+static struct platform_driver ast2600_espi_driver = {
+	.driver = {
+		.name = "ast2600-espi",
+		.of_match_table = ast2600_espi_of_matches,
+	},
+	.probe = ast2600_espi_probe,
+	.remove = ast2600_espi_remove,
+};
+
+module_platform_driver(ast2600_espi_driver);
+
+MODULE_AUTHOR("Chia-Wei Wang <chiawei_wang@aspeedtech.com>");
+MODULE_DESCRIPTION("Control of AST2600 eSPI Device");
+MODULE_LICENSE("GPL");
diff --git a/drivers/soc/aspeed/ast2600-espi.h b/drivers/soc/aspeed/ast2600-espi.h
new file mode 100644
index 000000000000..eb826f225e99
--- /dev/null
+++ b/drivers/soc/aspeed/ast2600-espi.h
@@ -0,0 +1,297 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2023 Aspeed Technology Inc.
+ */
+#ifndef _AST2600_ESPI_H_
+#define _AST2600_ESPI_H_
+
+#include <linux/bits.h>
+#include "aspeed-espi-comm.h"
+
+/* registers */
+#define ESPI_CTRL				0x000
+#define   ESPI_CTRL_FLASH_TX_SW_RST		BIT(31)
+#define   ESPI_CTRL_FLASH_RX_SW_RST		BIT(30)
+#define   ESPI_CTRL_OOB_TX_SW_RST		BIT(29)
+#define   ESPI_CTRL_OOB_RX_SW_RST		BIT(28)
+#define   ESPI_CTRL_PERIF_NP_TX_SW_RST		BIT(27)
+#define   ESPI_CTRL_PERIF_NP_RX_SW_RST		BIT(26)
+#define   ESPI_CTRL_PERIF_PC_TX_SW_RST		BIT(25)
+#define   ESPI_CTRL_PERIF_PC_RX_SW_RST		BIT(24)
+#define   ESPI_CTRL_FLASH_TX_DMA_EN		BIT(23)
+#define   ESPI_CTRL_FLASH_RX_DMA_EN		BIT(22)
+#define   ESPI_CTRL_OOB_TX_DMA_EN		BIT(21)
+#define   ESPI_CTRL_OOB_RX_DMA_EN		BIT(20)
+#define   ESPI_CTRL_PERIF_NP_TX_DMA_EN		BIT(19)
+#define   ESPI_CTRL_PERIF_PC_TX_DMA_EN		BIT(17)
+#define   ESPI_CTRL_PERIF_PC_RX_DMA_EN		BIT(16)
+#define   ESPI_CTRL_FLASH_SAFS_MODE		GENMASK(11, 10)
+#define   ESPI_CTRL_VW_GPIO_SW			BIT(9)
+#define   ESPI_CTRL_FLASH_SW_RDY		BIT(7)
+#define   ESPI_CTRL_OOB_SW_RDY			BIT(4)
+#define   ESPI_CTRL_VW_SW_RDY			BIT(3)
+#define   ESPI_CTRL_PERIF_SW_RDY		BIT(1)
+#define ESPI_STS				0x004
+#define ESPI_INT_STS				0x008
+#define   ESPI_INT_STS_RST_DEASSERT		BIT(31)
+#define   ESPI_INT_STS_OOB_RX_TMOUT		BIT(23)
+#define   ESPI_INT_STS_VW_SYSEVT1		BIT(22)
+#define   ESPI_INT_STS_FLASH_TX_ERR		BIT(21)
+#define   ESPI_INT_STS_OOB_TX_ERR		BIT(20)
+#define   ESPI_INT_STS_FLASH_TX_ABT		BIT(19)
+#define   ESPI_INT_STS_OOB_TX_ABT		BIT(18)
+#define   ESPI_INT_STS_PERIF_NP_TX_ABT		BIT(17)
+#define   ESPI_INT_STS_PERIF_PC_TX_ABT		BIT(16)
+#define   ESPI_INT_STS_FLASH_RX_ABT		BIT(15)
+#define   ESPI_INT_STS_OOB_RX_ABT		BIT(14)
+#define   ESPI_INT_STS_PERIF_NP_RX_ABT		BIT(13)
+#define   ESPI_INT_STS_PERIF_PC_RX_ABT		BIT(12)
+#define   ESPI_INT_STS_PERIF_NP_TX_ERR		BIT(11)
+#define   ESPI_INT_STS_PERIF_PC_TX_ERR		BIT(10)
+#define   ESPI_INT_STS_VW_GPIO			BIT(9)
+#define   ESPI_INT_STS_VW_SYSEVT		BIT(8)
+#define   ESPI_INT_STS_FLASH_TX_CMPLT		BIT(7)
+#define   ESPI_INT_STS_FLASH_RX_CMPLT		BIT(6)
+#define   ESPI_INT_STS_OOB_TX_CMPLT		BIT(5)
+#define   ESPI_INT_STS_OOB_RX_CMPLT		BIT(4)
+#define   ESPI_INT_STS_PERIF_NP_TX_CMPLT	BIT(3)
+#define   ESPI_INT_STS_PERIF_PC_TX_CMPLT	BIT(1)
+#define   ESPI_INT_STS_PERIF_PC_RX_CMPLT	BIT(0)
+#define ESPI_INT_EN				0x00c
+#define   ESPI_INT_EN_RST_DEASSERT		BIT(31)
+#define   ESPI_INT_EN_OOB_RX_TMOUT		BIT(23)
+#define   ESPI_INT_EN_VW_SYSEVT1		BIT(22)
+#define   ESPI_INT_EN_FLASH_TX_ERR		BIT(21)
+#define   ESPI_INT_EN_OOB_TX_ERR		BIT(20)
+#define   ESPI_INT_EN_FLASH_TX_ABT		BIT(19)
+#define   ESPI_INT_EN_OOB_TX_ABT		BIT(18)
+#define   ESPI_INT_EN_PERIF_NP_TX_ABT		BIT(17)
+#define   ESPI_INT_EN_PERIF_PC_TX_ABT		BIT(16)
+#define   ESPI_INT_EN_FLASH_RX_ABT		BIT(15)
+#define   ESPI_INT_EN_OOB_RX_ABT		BIT(14)
+#define   ESPI_INT_EN_PERIF_NP_RX_ABT		BIT(13)
+#define   ESPI_INT_EN_PERIF_PC_RX_ABT		BIT(12)
+#define   ESPI_INT_EN_PERIF_NP_TX_ERR		BIT(11)
+#define   ESPI_INT_EN_PERIF_PC_TX_ERR		BIT(10)
+#define   ESPI_INT_EN_VW_GPIO			BIT(9)
+#define   ESPI_INT_EN_VW_SYSEVT			BIT(8)
+#define   ESPI_INT_EN_FLASH_TX_CMPLT		BIT(7)
+#define   ESPI_INT_EN_FLASH_RX_CMPLT		BIT(6)
+#define   ESPI_INT_EN_OOB_TX_CMPLT		BIT(5)
+#define   ESPI_INT_EN_OOB_RX_CMPLT		BIT(4)
+#define   ESPI_INT_EN_PERIF_NP_TX_CMPLT		BIT(3)
+#define   ESPI_INT_EN_PERIF_PC_TX_CMPLT		BIT(1)
+#define   ESPI_INT_EN_PERIF_PC_RX_CMPLT		BIT(0)
+#define ESPI_PERIF_PC_RX_DMA			0x010
+#define ESPI_PERIF_PC_RX_CTRL			0x014
+#define   ESPI_PERIF_PC_RX_CTRL_SERV_PEND	BIT(31)
+#define   ESPI_PERIF_PC_RX_CTRL_LEN		GENMASK(23, 12)
+#define   ESPI_PERIF_PC_RX_CTRL_TAG		GENMASK(11, 8)
+#define   ESPI_PERIF_PC_RX_CTRL_CYC		GENMASK(7, 0)
+#define ESPI_PERIF_PC_RX_DATA			0x018
+#define ESPI_PERIF_PC_TX_DMA			0x020
+#define ESPI_PERIF_PC_TX_CTRL			0x024
+#define	  ESPI_PERIF_PC_TX_CTRL_TRIG_PEND	BIT(31)
+#define	  ESPI_PERIF_PC_TX_CTRL_LEN		GENMASK(23, 12)
+#define	  ESPI_PERIF_PC_TX_CTRL_TAG		GENMASK(11, 8)
+#define	  ESPI_PERIF_PC_TX_CTRL_CYC		GENMASK(7, 0)
+#define ESPI_PERIF_PC_TX_DATA			0x028
+#define ESPI_PERIF_NP_TX_DMA			0x030
+#define ESPI_PERIF_NP_TX_CTRL			0x034
+#define   ESPI_PERIF_NP_TX_CTRL_TRIG_PEND	BIT(31)
+#define	  ESPI_PERIF_NP_TX_CTRL_LEN		GENMASK(23, 12)
+#define	  ESPI_PERIF_NP_TX_CTRL_TAG		GENMASK(11, 8)
+#define	  ESPI_PERIF_NP_TX_CTRL_CYC		GENMASK(7, 0)
+#define ESPI_PERIF_NP_TX_DATA			0x038
+#define ESPI_OOB_RX_DMA				0x040
+#define ESPI_OOB_RX_CTRL			0x044
+#define	  ESPI_OOB_RX_CTRL_SERV_PEND		BIT(31)
+#define	  ESPI_OOB_RX_CTRL_LEN			GENMASK(23, 12)
+#define	  ESPI_OOB_RX_CTRL_TAG			GENMASK(11, 8)
+#define	  ESPI_OOB_RX_CTRL_CYC			GENMASK(7, 0)
+#define ESPI_OOB_RX_DATA			0x048
+#define ESPI_OOB_TX_DMA				0x050
+#define ESPI_OOB_TX_CTRL			0x054
+#define	  ESPI_OOB_TX_CTRL_TRIG_PEND		BIT(31)
+#define	  ESPI_OOB_TX_CTRL_LEN			GENMASK(23, 12)
+#define	  ESPI_OOB_TX_CTRL_TAG			GENMASK(11, 8)
+#define	  ESPI_OOB_TX_CTRL_CYC			GENMASK(7, 0)
+#define ESPI_OOB_TX_DATA			0x058
+#define ESPI_FLASH_RX_DMA			0x060
+#define ESPI_FLASH_RX_CTRL			0x064
+#define	  ESPI_FLASH_RX_CTRL_SERV_PEND		BIT(31)
+#define	  ESPI_FLASH_RX_CTRL_LEN		GENMASK(23, 12)
+#define	  ESPI_FLASH_RX_CTRL_TAG		GENMASK(11, 8)
+#define	  ESPI_FLASH_RX_CTRL_CYC		GENMASK(7, 0)
+#define ESPI_FLASH_RX_DATA			0x068
+#define ESPI_FLASH_TX_DMA			0x070
+#define ESPI_FLASH_TX_CTRL			0x074
+#define	  ESPI_FLASH_TX_CTRL_TRIG_PEND		BIT(31)
+#define	  ESPI_FLASH_TX_CTRL_LEN		GENMASK(23, 12)
+#define	  ESPI_FLASH_TX_CTRL_TAG		GENMASK(11, 8)
+#define	  ESPI_FLASH_TX_CTRL_CYC		GENMASK(7, 0)
+#define ESPI_FLASH_TX_DATA			0x078
+#define ESPI_CTRL2				0x080
+#define   ESPI_CTRL2_VW_TX_SORT			BIT(30)
+#define   ESPI_CTRL2_MCYC_RD_DIS_WDT		BIT(11)
+#define   ESPI_CTRL2_MCYC_WR_DIS_WDT		BIT(10)
+#define   ESPI_CTRL2_MCYC_RD_DIS		BIT(6)
+#define   ESPI_CTRL2_MMBI_RD_DIS		ESPI_CTRL2_MCYC_RD_DIS
+#define   ESPI_CTRL2_MCYC_WR_DIS		BIT(4)
+#define   ESPI_CTRL2_MMBI_WR_DIS		ESPI_CTRL2_MCYC_WR_DIS
+#define ESPI_PERIF_MCYC_SADDR			0x084
+#define ESPI_PERIF_MMBI_SADDR			ESPI_PERIF_MCYC_SADDR
+#define ESPI_PERIF_MCYC_TADDR			0x088
+#define ESPI_PERIF_MMBI_TADDR			ESPI_PERIF_MCYC_TADDR
+#define ESPI_PERIF_MCYC_MASK			0x08c
+#define ESPI_PERIF_MMBI_MASK			ESPI_PERIF_MCYC_MASK
+#define ESPI_FLASH_SAFS_TADDR			0x090
+#define   ESPI_FLASH_SAFS_TADDR_BASE		GENMASK(31, 24)
+#define   ESPI_FLASH_SAFS_TADDR_MASK		GENMASK(15, 8)
+#define ESPI_VW_SYSEVT_INT_EN			0x094
+#define ESPI_VW_SYSEVT				0x098
+#define   ESPI_VW_SYSEVT_HOST_RST_ACK		BIT(27)
+#define   ESPI_VW_SYSEVT_RST_CPU_INIT		BIT(26)
+#define   ESPI_VW_SYSEVT_SLV_BOOT_STS		BIT(23)
+#define   ESPI_VW_SYSEVT_NON_FATAL_ERR		BIT(22)
+#define   ESPI_VW_SYSEVT_FATAL_ERR		BIT(21)
+#define   ESPI_VW_SYSEVT_SLV_BOOT_DONE		BIT(20)
+#define   ESPI_VW_SYSEVT_OOB_RST_ACK		BIT(16)
+#define   ESPI_VW_SYSEVT_NMI_OUT		BIT(10)
+#define   ESPI_VW_SYSEVT_SMI_OUT		BIT(9)
+#define   ESPI_VW_SYSEVT_HOST_RST_WARN		BIT(8)
+#define   ESPI_VW_SYSEVT_OOB_RST_WARN		BIT(6)
+#define   ESPI_VW_SYSEVT_PLTRSTN		BIT(5)
+#define   ESPI_VW_SYSEVT_SUSPEND		BIT(4)
+#define   ESPI_VW_SYSEVT_S5_SLEEP		BIT(2)
+#define   ESPI_VW_SYSEVT_S4_SLEEP		BIT(1)
+#define   ESPI_VW_SYSEVT_S3_SLEEP		BIT(0)
+#define ESPI_VW_GPIO_VAL			0x09c
+#define ESPI_GEN_CAP_N_CONF			0x0a0
+#define ESPI_CH0_CAP_N_CONF			0x0a4
+#define ESPI_CH1_CAP_N_CONF			0x0a8
+#define ESPI_CH2_CAP_N_CONF			0x0ac
+#define ESPI_CH3_CAP_N_CONF			0x0b0
+#define ESPI_CH3_CAP_N_CONF2			0x0b4
+#define ESPI_VW_GPIO_DIR			0x0c0
+#define ESPI_VW_GPIO_GRP			0x0c4
+#define ESPI_INT_EN_CLR				0x0fc
+#define ESPI_VW_SYSEVT1_INT_EN			0x100
+#define ESPI_VW_SYSEVT1				0x104
+#define   ESPI_VW_SYSEVT1_SUSPEND_ACK		BIT(20)
+#define   ESPI_VW_SYSEVT1_SUSPEND_WARN		BIT(0)
+#define ESPI_VW_SYSEVT_INT_T0			0x110
+#define ESPI_VW_SYSEVT_INT_T1			0x114
+#define ESPI_VW_SYSEVT_INT_T2			0x118
+#define ESPI_VW_SYSEVT_INT_STS			0x11c
+#define ESPI_VW_SYSEVT1_INT_T0			0x120
+#define ESPI_VW_SYSEVT1_INT_T1			0x124
+#define ESPI_VW_SYSEVT1_INT_T2			0x128
+#define ESPI_VW_SYSEVT1_INT_STS			0x12c
+#define ESPI_OOB_RX_DESC_NUM			0x130
+#define ESPI_OOB_RX_DESC_RPTR			0x134
+#define	  ESPI_OOB_RX_DESC_RPTR_UPDATE		BIT(31)
+#define   ESPI_OOB_RX_DESC_RPTR_RP		GENMASK(11, 0)
+#define ESPI_OOB_RX_DESC_WPTR			0x138
+#define   ESPI_OOB_RX_DESC_WPTR_RECV_EN		BIT(31)
+#define   ESPI_OOB_RX_DESC_WPTR_SP		GENMASK(27, 16)
+#define   ESPI_OOB_RX_DESC_WPTR_WP		GENMASK(11, 0)
+#define ESPI_OOB_TX_DESC_NUM			0x140
+#define ESPI_OOB_TX_DESC_RPTR			0x144
+#define	  ESPI_OOB_TX_DESC_RPTR_UPDATE		BIT(31)
+#define ESPI_OOB_TX_DESC_WPTR			0x148
+#define	  ESPI_OOB_TX_DESC_WPTR_SEND_EN		BIT(31)
+#define ESPI_MMBI_CTRL				0x800
+#define   ESPI_MMBI_CTRL_INST_SZ		GENMASK(10, 8)
+#define   ESPI_MMBI_CTRL_TOTAL_SZ		GENMASK(6, 4)
+#define   ESPI_MMBI_CTRL_EN			BIT(0)
+#define ESPI_MMBI_INT_STS			0x808
+#define ESPI_MMBI_INT_EN			0x80c
+#define ESPI_MMBI_HOST_RWP(x)			(0x810 + ((x) << 3))
+
+/* collect ESPI_INT_EN bits for convenience */
+#define ESPI_INT_EN_PERIF			\
+	(ESPI_INT_EN_PERIF_NP_TX_ABT |		\
+	 ESPI_INT_EN_PERIF_PC_TX_ABT |		\
+	 ESPI_INT_EN_PERIF_NP_RX_ABT |		\
+	 ESPI_INT_EN_PERIF_PC_RX_ABT |		\
+	 ESPI_INT_EN_PERIF_NP_TX_ERR |		\
+	 ESPI_INT_EN_PERIF_PC_TX_ERR |		\
+	 ESPI_INT_EN_PERIF_NP_TX_CMPLT |	\
+	 ESPI_INT_EN_PERIF_PC_TX_CMPLT |	\
+	 ESPI_INT_EN_PERIF_PC_RX_CMPLT)
+
+#define ESPI_INT_EN_VW			\
+	(ESPI_INT_EN_VW_SYSEVT1 |	\
+	 ESPI_INT_EN_VW_GPIO    |	\
+	 ESPI_INT_EN_VW_SYSEVT)
+
+#define ESPI_INT_EN_OOB		\
+	(ESPI_INT_EN_OOB_RX_TMOUT |	\
+	 ESPI_INT_EN_OOB_TX_ERR |	\
+	 ESPI_INT_EN_OOB_TX_ABT |	\
+	 ESPI_INT_EN_OOB_RX_ABT |	\
+	 ESPI_INT_EN_OOB_TX_CMPLT |	\
+	 ESPI_INT_EN_OOB_RX_CMPLT)
+
+#define ESPI_INT_EN_FLASH		\
+	(ESPI_INT_EN_FLASH_TX_ERR |	\
+	 ESPI_INT_EN_FLASH_TX_ABT |	\
+	 ESPI_INT_EN_FLASH_RX_ABT |	\
+	 ESPI_INT_EN_FLASH_TX_CMPLT |	\
+	 ESPI_INT_EN_FLASH_RX_CMPLT)
+
+/* collect ESPI_INT_STS bits for convenience */
+#define ESPI_INT_STS_PERIF			\
+	(ESPI_INT_STS_PERIF_NP_TX_ABT |		\
+	 ESPI_INT_STS_PERIF_PC_TX_ABT |		\
+	 ESPI_INT_STS_PERIF_NP_RX_ABT |		\
+	 ESPI_INT_STS_PERIF_PC_RX_ABT |		\
+	 ESPI_INT_STS_PERIF_NP_TX_ERR |		\
+	 ESPI_INT_STS_PERIF_PC_TX_ERR |		\
+	 ESPI_INT_STS_PERIF_NP_TX_CMPLT |	\
+	 ESPI_INT_STS_PERIF_PC_TX_CMPLT |	\
+	 ESPI_INT_STS_PERIF_PC_RX_CMPLT)
+
+#define ESPI_INT_STS_VW			\
+	(ESPI_INT_STS_VW_SYSEVT1 |	\
+	 ESPI_INT_STS_VW_GPIO    |	\
+	 ESPI_INT_STS_VW_SYSEVT)
+
+#define ESPI_INT_STS_OOB		\
+	(ESPI_INT_STS_OOB_RX_TMOUT |	\
+	 ESPI_INT_STS_OOB_TX_ERR |	\
+	 ESPI_INT_STS_OOB_TX_ABT |	\
+	 ESPI_INT_STS_OOB_RX_ABT |	\
+	 ESPI_INT_STS_OOB_TX_CMPLT |	\
+	 ESPI_INT_STS_OOB_RX_CMPLT)
+
+#define ESPI_INT_STS_FLASH		\
+	(ESPI_INT_STS_FLASH_TX_ERR |	\
+	 ESPI_INT_STS_FLASH_TX_ABT |	\
+	 ESPI_INT_STS_FLASH_RX_ABT |	\
+	 ESPI_INT_STS_FLASH_TX_CMPLT |	\
+	 ESPI_INT_STS_FLASH_RX_CMPLT)
+
+/* consistent with DTS property "flash-safs-mode" */
+enum ast2600_safs_mode {
+	SAFS_MODE_MIX = 0x0,
+	SAFS_MODE_SW,
+	SAFS_MODE_HW,
+	SAFS_MODES,
+};
+
+/* consistent with DTS property "perif-mmbi-instance-size" */
+enum ast2600_mmbi_instance_size {
+	MMBI_INST_SIZE_8KB = 0x0,
+	MMBI_INST_SIZE_16KB,
+	MMBI_INST_SIZE_32KB,
+	MMBI_INST_SIZE_64KB,
+	MMBI_INST_SIZE_128KB,
+	MMBI_INST_SIZE_256KB,
+	MMBI_INST_SIZE_512KB,
+	MMBI_INST_SIZE_1024KB,
+	MMBI_INST_SIZE_TYPES,
+};
+
+#endif
-- 
2.34.1

